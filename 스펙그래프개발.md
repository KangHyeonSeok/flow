프로젝트 기능 구조 그래프 시스템

---

# 🧭 왜 만드는가

AI가 코딩을 맡는 시대에 **개발자의 핵심 역할은 "문제를 정의하는 사람"** 으로 전환된다.

그러나 지금까지 문제 정의는 이슈 트래커의 단편적인 티켓이나 일차원적인 문서 형태에 머물러 있었다. 기능 간 의존 관계, 영향 범위, 검증 상태 같은 **구조적 맥락**이 빠져 있기 때문에 개발자가 전체 그림을 파악하려면 흩어진 문서와 코드를 직접 추적해야 했고, 이 과정에 막대한 인지 비용이 들었다.

**스펙 그래프는 이 문제를 해결한다.**

| 기존 방식 | 스펙 그래프 |
|---|---|
| 이슈 트래커에 흩어진 단편 티켓 | 기능·조건·의존성이 **하나의 그래프**로 연결 |
| 문서를 읽어야 구조 파악 | 그래프 위에서 **한눈에** 전체 구조 확인 |
| 코드 변경 시 영향 범위 수동 추적 | 영향 분석·상태 전파가 **자동 계산** |
| 테스트 상태를 CI 로그에서 확인 | 각 노드에 테스트 건강도·실패 이력이 **직접 연결** |

### 역할 분담: 사람 vs AI

```text
┌──────────────────────────────────┐     ┌──────────────────────────────────┐
│          개발자 (사람)             │     │            AI 에이전트            │
│                                  │     │                                  │
│  • 스펙 구조 설계 및 제어          │     │  • 스펙 JSON 생성·수정            │
│  • 조건(Condition) 정의·변경       │     │  • 코드 구현                      │
│  • 의존성·우선순위 판단            │     │  • 테스트 코드 작성                │
│  • 그래프 위에서 전체 현황 모니터링  │     │  • 테스트 결과 동기화              │
│  • 최종 승인·머지 결정             │     │  • 영향 분석·상태 전파 계산         │
│                                  │     │                                  │
│  인터페이스: VSCode 확장 / 웹뷰    │     │  인터페이스: CLI / API             │
└──────────────────────────────────┘     └──────────────────────────────────┘
```

즉, **코딩과 스펙 문서(JSON) 자체는 AI가 만들고**, 개발자는 VSCode 확장이나 웹뷰로 잘 정리된 그래프 위에서 스펙을 입력하고, 조건을 변경하고, 구조를 제어한다. 개발자는 "어떻게 만들 것인가"가 아니라 **"무엇을 만들 것인가"** 에 집중하게 된다.

---

# 🎯 0️⃣ 시스템 정의

## 핵심 개념

* Node = 기능(Spec)
* Edge = 의존/영향 관계
* Evidence = 동작 증거
* CodeRef = 코드 연결
* Hierarchy = 상위/하위 기능

즉, 이건 **Feature Dependency Graph** 입니다.

## JSON 스펙 스키마 (v4)

모든 스펙 파일은 `docs/specs/` 하위에 `{id}.json` 형태로 저장한다. 스펙 내의 `conditions` 배열은 하부 노드(조건 노드)로 취급되어 그래프 렌더링 시 별도의 노드로 분리된다. v3에서는 **테스트 연결 정보**, v4에서는 **GitHub Refs·문서 링크**가 추가되어 이슈/PR 번호 및 관련 문서를 노드에 직접 연결할 수 있다.

> **⚠️ 스키마 복잡도 경고 — Progressive Disclosure 전략 (10️⃣-D 참조)**
> 현재 v4 스키마는 `e2eScenarios`, `requirements`, `successCriteria`, `edgeCases` 등 매우 많은 정보를 담고 있다.
> 초기 도입 시 팀원들이 이 거대한 JSON 템플릿을 마주하면 작성 자체를 포기할 확률이 높다.
> 따라서 **초기 생성 시에는 최소 스키마(id, title, description, status, conditions)만 필수**로 강제하고,
> 나머지 필드는 AI가 코드·테스트를 분석해 **점진적으로 채워 넣도록(Backfill)** 설계한다.

> **명령어 표기 규칙 (중요)**
> - 이 문서의 CLI 예시는 현재 저장소 구현 기준으로 `flow spec-*` 형식을 사용한다.
> - 예: `flow spec-validate`, `flow spec-graph`, `flow spec-backup`
> - `flow spec <subcommand>` 형식은 향후 alias로 추가할 수 있으나, 현행 기준 권장 표기는 `spec-*`이다.

```jsonc
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "schemaVersion": 4,               // ← 스키마 버전 v4 (GitHub Refs·DocLinks 추가, v3 하위 호환)
  "id": "F-010",                     // unique, 필수
  "nodeType": "feature",            // feature | condition (그래프 렌더링 시 노드 타입 구분)
  "title": "로그인 기능",
  "description": "사용자 로그인 처리",
  "status": "verified",             // draft | active | needs-review | verified | deprecated
  "parent": "F-001",                // nullable, 상위 스펙 id
  "dependencies": ["F-002","F-003"],// 의존하는 스펙 id 배열
  "conditions": [                   // 개별 수락 조건 (그래프 상에서 하위 노드로 취급됨)
    {
      "id": "F-010-C1",
      "nodeType": "condition",
      "description": "Given 유효한 자격증명, When 로그인 시도, Then 토큰 발급",
      "status": "verified",
      "codeRefs": ["tools/flow-cli/Services/AuthService.cs#Method:Login"],
      // ⚠️ codeRefs는 라인 번호(#L20-L30) 대신 심볼 참조(#Method:Login) 사용 권장 (10️⃣-A 참조)
      "githubRefs": [{ "type": "issue", "number": 42 }],  // ← v4: GitHub 이슈/PR 연결 (선택)
      "docLinks": [],                                       // ← v4: 관련 문서 링크 (선택)
      "evidence": [
        {
          "type": "log",
          "path": "docs/evidence/F-010-C1/login_success.log",
          "capturedAt": "2026-02-28T09:00:00Z"
        }
      ],
      "tests": [                    // ← v3: 조건 노드에 연결된 단위/통합 테스트
        {
          "id": "F-010-C1-T1",
          "type": "unit",            // unit | integration | performance
          "description": "유효한 자격증명으로 토큰 발급 성공 검증",
          "testName": "AuthServiceTests.Login_WithValidCredentials_ReturnsToken",
          "framework": "xUnit",     // xUnit | Jest | pytest | NUnit 등
          "codeRefs": ["tools/flow-cli.Tests/AuthServiceTests.cs#L15-L35"],
          "lastRun": {              // 가장 최근 실행 결과
            "status": "passed",     // passed | failed | skipped | error
            "executedAt": "2026-02-28T09:00:00Z",
            "duration": 120,        // 밀리초
            "runner": "CI",         // CI | local
            "buildId": "gh-actions-1234"  // CI 빌드 참조 (선택)
          },
          "lastFailure": {          // nullable — 마지막 실패 기록
            "failedAt": "2026-02-25T14:30:00Z",
            "message": "Expected token but got null",
            "stackTrace": "AuthService.cs:L25 → TokenProvider.cs:L12",
            "buildId": "gh-actions-1200",
            "resolvedAt": "2026-02-25T16:00:00Z"
          },
          "history": {              // 테스트 안정성 지표
            "totalRuns": 45,
            "passCount": 43,
            "failCount": 2,
            "skipCount": 0,
            "flakyScore": 0.04,     // failCount/totalRuns — flaky 감지 지표
            "firstRun": "2026-01-20T00:00:00Z",
            "lastPassedAt": "2026-02-28T09:00:00Z"
          },
          "tags": ["smoke", "critical"]  // 테스트 분류 태그
        }
      ]
    }
  ],
  "codeRefs": [                     // 스펙 공통 또는 래퍼 코드 참조
    "tools/flow-cli/Services/AuthService.cs#L10-L45"
  ],
  "githubRefs": [                   // ← v4: GitHub 이슈/PR/Discussion 연결 (선택)
    { "type": "issue",       "number": 42, "title": "인증 서비스 설계 논의" },
    { "type": "pr",          "number": 87, "title": "AuthService 초기 구현" }
  ],
  "docLinks": [                     // ← v4: 관련 문서·참고자료 링크 (선택)
    { "type": "doc",       "title": "인증 설계 문서",  "path": "docs/design/auth.md" },
    { "type": "reference", "title": "RFC 6749 OAuth2", "url": "https://datatracker.ietf.org/doc/html/rfc6749" }
  ],
  "tests": [                        // ← v3: 기능 수준의 통합/크로스커팅 테스트
    {
      "id": "F-010-T1",
      "type": "integration",
      "description": "AuthService → TokenProvider → DB 통합 테스트",
      "testName": "AuthIntegrationTests.FullLoginFlow",
      "framework": "xUnit",
      "codeRefs": ["tools/flow-cli.Tests/AuthIntegrationTests.cs#L10-L50"],
      "lastRun": { "status": "passed", "executedAt": "2026-02-28T09:00:00Z", "duration": 850, "runner": "CI" },
      "lastFailure": null,
      "history": { "totalRuns": 30, "passCount": 30, "failCount": 0, "skipCount": 0, "flakyScore": 0.0, "firstRun": "2026-02-01T00:00:00Z", "lastPassedAt": "2026-02-28T09:00:00Z" },
      "tags": ["integration"]
    }
  ],
  "e2eScenarios": [                 // ← v3: E2E 테스트 시나리오
    {
      "id": "F-010-E2E-1",
      "description": "사용자 로그인 전체 플로우 E2E 검증",
      "preconditions": ["테스트 DB 초기화", "테스트 사용자 생성"],
      "steps": [
        "POST /api/auth/login {email, password}",
        "응답에서 accessToken 추출",
        "GET /api/profile (Authorization: Bearer {token})",
        "프로필 정보 정상 반환 확인"
      ],
      "expectedResult": "로그인 → 토큰 발급 → 인증된 API 호출 성공",
      "codeRefs": ["tools/e2e-test/scenarios/auth_login.py"],
      "lastRun": {
        "status": "passed",
        "executedAt": "2026-02-28T10:00:00Z",
        "duration": 3500,
        "runner": "CI",
        "environment": "staging"    // 실행 환경
      },
      "lastFailure": null,
      "history": { "totalRuns": 15, "passCount": 14, "failCount": 1, "skipCount": 0, "flakyScore": 0.07, "firstRun": "2026-02-10T00:00:00Z", "lastPassedAt": "2026-02-28T10:00:00Z" },
      "tags": ["critical-path", "auth"]
    }
  ],
  // ⚠️ 동적 상태 데이터(lastRun, history, testSummary) 분리 전략 (10️⃣-B 참조)
  // JSON 파일에는 불변하는 스펙(설계, 의존성, 요구사항)만 저장하고,
  // 테스트 결과·실행 이력 등 동적 데이터는 별도 캐시 레이어(SQLite 등)에서
  // 런타임에 그래프와 병합(Merge)하여 UI에 표시하는 방식을 권장한다.
  "testSummary": {                  // ← v3: 기능 전체 테스트 집계 (자동 계산, 별도 캐시 권장)
    "total": 8,
    "passed": 7,
    "failed": 0,
    "skipped": 1,
    "error": 0,
    "coverage": 78.5,               // 코드 커버리지 % (선택)
    "lastFullRun": "2026-02-28T09:00:00Z",
    "healthScore": 0.92,            // 종합 테스트 건강도 (0.0~1.0)
    "flakyTests": [],               // flaky로 판정된 테스트 ID 목록
    "avgDuration": 450,             // 전체 테스트 평균 실행 시간 (ms)
    "trend": "stable"               // improving | stable | degrading
  },
  "evidence": [                     // 기능 수준의 공통 증거
    {
      "type": "screenshot",          // screenshot | log | metric | test-result
      "path": "docs/evidence/F-010/login_ok.png",
      "capturedAt": "2026-02-28T09:00:00Z"
    }
  ],
  "tags": ["auth", "security"],
  "priority": "P1",                          // P1 | P2 | P3 (선택)
  "requirements": {                            // 선택: RFC 2119
    "must": ["유효한 자격증명으로 로그인 가능"],
    "should": ["실패 메시지는 원인 범주를 구분"],
    "may": ["remember me 옵션 지원"]
  },
  "successCriteria": ["P95 로그인 응답 2초 이내"],  // 선택
  "edgeCases": ["잠긴 계정 로그인 시도"],            // 선택
  "metadata": {},                               // 자유 확장 필드
  "computedStatus": "stable",                 // 선택: 집계/표시 전용 (stable | partial | blocked)
  "createdAt": "2026-01-15T00:00:00Z",
  "updatedAt": "2026-02-28T00:00:00Z"
}
```

### v3 테스트 스키마 상세 정의

#### `tests` — 단위/통합 테스트 배열

조건(condition) 노드와 기능(feature) 노드 모두에 연결 가능. 각 테스트는 실제 테스트 코드와 1:1 매핑된다.

| 필드 | 타입 | 필수 | 설명 |
|---|---|---|---|
| `id` | string | 필수 | 고유 테스트 ID (`{스펙ID}-{C번호}-T{번호}` 또는 `{스펙ID}-T{번호}`) |
| `type` | enum | 필수 | `unit` \| `integration` \| `performance` |
| `description` | string | 필수 | 테스트가 검증하는 내용 |
| `testName` | string | 필수 | 테스트 프레임워크 상의 정규화된 테스트 이름 (클래스.메서드) |
| `framework` | string | 권장 | 사용 프레임워크 (`xUnit`, `Jest`, `pytest` 등) |
| `codeRefs` | string[] | 필수 | 테스트 코드 파일 경로 + 라인 범위 |
| `lastRun` | object | 선택 | 최근 실행 결과 (아래 참조) |
| `lastFailure` | object\|null | 선택 | 최근 실패 기록 (아래 참조) |
| `history` | object | 선택 | 누적 실행 통계 (아래 참조) |
| `tags` | string[] | 선택 | 테스트 분류 (`smoke`, `critical`, `regression`, `nightly`) |

#### `lastRun` — 최근 실행 결과

| 필드 | 타입 | 설명 |
|---|---|---|
| `status` | enum | `passed` \| `failed` \| `skipped` \| `error` |
| `executedAt` | ISO 8601 | 실행 시각 |
| `duration` | number | 실행 시간 (밀리초) |
| `runner` | string | `CI` \| `local` |
| `buildId` | string? | CI 빌드 ID 또는 파이프라인 참조 |

#### `lastFailure` — 최근 실패 기록

| 필드 | 타입 | 설명 |
|---|---|---|
| `failedAt` | ISO 8601 | 실패 발생 시각 |
| `message` | string | 실패 메시지 (assertion failure, exception 등) |
| `stackTrace` | string? | 축약된 스택 트레이스 |
| `buildId` | string? | 실패 발생 빌드 ID |
| `resolvedAt` | ISO 8601? | 실패 해결 시각 (null이면 미해결) |

#### `history` — 누적 실행 통계

| 필드 | 타입 | 설명 |
|---|---|---|
| `totalRuns` | number | 총 실행 횟수 |
| `passCount` | number | 성공 횟수 |
| `failCount` | number | 실패 횟수 |
| `skipCount` | number | 스킵 횟수 |
| `flakyScore` | number | `failCount / totalRuns` (0.0~1.0). 0.1 이상이면 flaky 경고 |
| `firstRun` | ISO 8601 | 최초 실행 시각 |
| `lastPassedAt` | ISO 8601? | 마지막 성공 시각 |

#### `e2eScenarios` — E2E 테스트 시나리오 배열 (기능 노드 전용)

| 필드 | 타입 | 필수 | 설명 |
|---|---|---|---|
| `id` | string | 필수 | 고유 시나리오 ID (`{스펙ID}-E2E-{번호}`) |
| `description` | string | 필수 | 시나리오 설명 |
| `preconditions` | string[] | 권장 | 사전 조건 목록 |
| `steps` | string[] | 필수 | 실행 단계 (순서대로) |
| `expectedResult` | string | 필수 | 기대 결과 |
| `codeRefs` | string[] | 필수 | E2E 테스트 코드 경로 |
| `lastRun` | object | 선택 | 최근 실행 결과 (`lastRun` + `environment` 필드 추가) |
| `lastFailure` | object\|null | 선택 | 최근 실패 기록 |
| `history` | object | 선택 | 누적 실행 통계 |
| `tags` | string[] | 선택 | 시나리오 분류 (`critical-path`, `regression`, `smoke`) |

#### `testSummary` — 기능 전체 테스트 집계 (자동 계산)

기능 노드의 모든 테스트(`tests` + `conditions[].tests` + `e2eScenarios`)를 집계한 요약. CLI가 자동으로 계산·갱신한다.

| 필드 | 타입 | 설명 |
|---|---|---|
| `total` | number | 전체 테스트 수 |
| `passed` | number | 성공 수 |
| `failed` | number | 실패 수 |
| `skipped` | number | 스킵 수 |
| `error` | number | 에러 수 (테스트 코드 자체 오류) |
| `coverage` | number? | 코드 커버리지 % (CI 연동 시) |
| `lastFullRun` | ISO 8601 | 전체 테스트 마지막 실행 시각 |
| `healthScore` | number | 종합 건강도 (0.0~1.0) = `(passed - flakyPenalty) / total` |
| `flakyTests` | string[] | flaky 판정 테스트 ID 목록 (`flakyScore ≥ 0.1`) |
| `avgDuration` | number | 평균 실행 시간 (ms) |
| `trend` | enum | `improving` \| `stable` \| `degrading` — 최근 5회 실행 추세 |

### v4 GitHub Refs·DocLinks 상세 정의

#### `githubRefs` — GitHub 이슈·PR·Discussion 연결 (선택)

`feature` 노드와 `condition` 노드 모두에 적용 가능. 이슈 단위로 관련 논의를 추적하거나 PR로 구현 이력을 연결한다.

| 필드 | 타입 | 필수 | 설명 |
|---|---|---|---|
| `type` | enum | 필수 | `issue` \| `pr` \| `discussion` |
| `number` | number | 필수 | 이슈/PR/Discussion 번호 |
| `title` | string | 선택 | 제목 (미입력 시 GitHub에서 조회 가능) |
| `url` | string | 선택 | 직접 URL 지정 (미입력 시 `number` 기반 자동 구성 가능) |

#### `docLinks` — 관련 문서·참고자료 링크 (선택)

`feature` 노드와 `condition` 노드 모두에 적용 가능. 프로젝트 내 파일(상대 경로), 외부 연구/RFC/공식 문서, 웹 URL 등 다양한 자료를 연결한다.

| 필드 | 타입 | 필수 | 설명 |
|---|---|---|---|
| `type` | enum | 필수 | `doc` (프로젝트 내 문서) \| `reference` (외부 참고자료) \| `url` (자유 URL) |
| `title` | string | 필수 | 링크 표시 제목 |
| `path` | string | 조건부 | 워크스페이스 기준 상대 경로 (`doc` 타입 시 사용, 에디터에서 바로 열기 지원) |
| `url` | string | 조건부 | 외부 URL (`reference`, `url` 타입 시 사용, 브라우저로 열기) |

### 스키마 버전 관리 전략

| 버전 | 변경 내용 | 호환성 |
|---|---|---|
| v1 | 초기 스키마 | - |
| v2 | 조건의 하위 노드화 (`conditions[].nodeType`) | v1과 하위 호환 |
| v3 | 테스트 연결 (`tests`, `e2eScenarios`, `testSummary`) | v2와 하위 호환 (모든 신규 필드 선택) |
| v4 | GitHub 연결·문서 링크 (`githubRefs`, `docLinks`) | v3와 하위 호환 (모든 신규 필드 선택) |

| 버전 변경 유형 | 처리 방식 |
|---|---|
| 필드 추가 (선택) | 하위 호환 - 마이그레이션 불필요 |
| 필드 추가 (필수) | 마이그레이션 스크립트로 기본값 주입 후 `schemaVersion` 업 |
| 필드 변경/삭제 | 마이그레이션 스크립트 + 이전 버전 읽기 어댑터 유지 (최소 1세대) |

* `docs/specs/.schema-version` 파일에 현재 스키마 버전 기록
* CLI `flow spec-migrate` 명령으로 일괄 마이그레이션 실행 (계획)
* 마이그레이션 전 자동 백업(`docs/specs/.backup/{timestamp}/`)
* v2 → v3 마이그레이션: `tests: []`, `e2eScenarios: []`, `testSummary: null` 기본값 주입 (선택 필드이므로 자동 호환)
* v3 → v4 마이그레이션: `githubRefs: []`, `docLinks: []` 기본값 주입 (선택 필드이므로 자동 호환)

## 스펙의 개념 정의 — 무엇을 스펙으로 볼 것인가

### 스펙(Spec)이란

스펙은 **사용자에게 가치를 전달하는 최소 독립 기능 단위**이다.
코드의 클래스나 함수가 아니라, **사용자 여정(User Journey)** 관점에서 정의한다.

| 스펙이 맞는 것 | 스펙이 아닌 것 |
|---|---|
| "사용자가 로그인할 수 있다" | "AuthService 클래스를 구현한다" |
| "검색 결과를 페이지네이션한다" | "Repository 패턴을 적용한다" |
| "빌드 결과를 JSON으로 내보낸다" | "Utils 폴더 리팩토링" |

### 스펙 하나에 담아야 하는 것

| 구성 요소 | 설명 | 필수 여부 |
|---|---|---|
| **제목(title)** | 사용자 관점의 한 줄 설명 | 필수 |
| **설명(description)** | 무엇을 하는 기능인지, 왜 필요한지 | 필수 |
| **수락 조건(Conditions)** | Given/When/Then 형식의 검증 가능한 조건 3~7개. **그래프 상에서 각각 별도의 하위 노드**로 렌더링되며 독립된 상태/코드참조를 가짐. | 필수 |
| **단위/통합 테스트(tests)** | 조건·기능별 테스트 코드 참조, 실행 이력, 실패 기록. **스펙과 테스트 코드의 1:1 매핑** | 권장 |
| **E2E 시나리오(e2eScenarios)** | 사용자 여정 전체 플로우 검증. 사전조건·단계·기대결과 포함 | 권장 |
| **테스트 요약(testSummary)** | 전체 테스트 집계 — 통과/실패/커버리지/건강도 (CLI 자동 계산) | 자동 |
| **우선순위(Priority)** | P1(핵심) / P2(중요) / P3(부가) — 구현 순서 결정 | 권장 |
| **요구사항(Requirements)** | MUST / SHOULD / MAY (RFC 2119) 키워드로 구분 | 권장 |
| **성공 지표(Success Criteria)** | 측정 가능한 결과 ("2초 이내 응답", "90% 성공률") | 권장 |
| **경계 조건(Edge Cases)** | 에러 시나리오, 경계값 동작 | 권장 |
| **불확실한 부분** | `[NEEDS CLARIFICATION: ...]`으로 명시적 표기 | 해당 시 |

### 스펙의 범위 — 어떻게 잘라야 하는가

**핵심 원칙: 각 스펙은 독립적으로 테스트·배포·데모 가능해야 한다.**

```text
[좋은 예]
F-010: 사용자 로그인
  → 이것만 구현해도 동작하는 MVP
  → Given 유효한 자격증명, When 로그인 시도, Then 토큰 발급

F-011: 비밀번호 재설정
  → F-010 없이도 독립 테스트 가능 (이메일 전송만)
  → Given 등록된 이메일, When 재설정 요청, Then 이메일 발송

[나쁜 예]
F-020: 사용자 관리 전체
  → 너무 광범위, 독립 테스트 불가, 완료 기준 모호
```

| 규칙 | 설명 |
|---|---|
| **1 스펙 = 1 사용자 여정** | 하나의 JSON 스펙이 하나의 사용자 여정과 대응 |
| **독립 배포 가능** | 이 스펙만 구현해도 가치를 전달할 수 있는가? |
| **2주 이내 구현** | 2주 초과 예상 시 하위 스펙으로 분할 |
| **수락 조건 3~7개** | 3개 미만 = 너무 작거나 모호, 7개 초과 = 분할 필요 |
| **MUST/SHOULD/MAY 구분** | RFC 2119 키워드로 필수·권장·선택 명확히 |

### 스펙 검증 — 어떻게 검증하는가

| 검증 단계 | 질문 | 불합격 기준 |
|---|---|---|
| **1. 완결성** | 수락 조건이 3개 이상인가? | 조건 부족 or "미정" 상태 존재 |
| **2. 독립성** | 이 스펙만으로 테스트 가능한가? | 다른 스펙 구현 없이 검증 불가 |
| **3. 측정 가능성** | 성공/실패를 객관적으로 판단 가능한가? | "잘 동작해야 함" 같은 모호한 기준 |
| **4. 범위 적절성** | 2주 이내 구현 가능한가? | 범위가 너무 넓거나 너무 좁음 |
| **5. 참조 무결성** | parent/dependencies가 존재하는 스펙인가? | 존재하지 않는 ID 참조 |
| **6. 코드 연결** | codeRefs가 실제 파일을 가리키는가? | 존재하지 않는 파일 참조 |
| **7. 순환 참조** | 그래프에 cycle이 없는가? | Kahn 알고리즘으로 감지 |
| **8. 테스트 연결** | 각 조건에 테스트가 1개 이상 연결되어 있는가? | 테스트 없는 조건 존재 (`--strict` 모드) |
| **9. 테스트 건강도** | `testSummary.healthScore` ≥ 0.8 인가? | 건강도 기준 미달 시 warning |
| **10. 테스트 코드 존재** | `tests[].codeRefs`가 실제 테스트 파일을 가리키는가? | 존재하지 않는 테스트 파일 참조 |

CI에서 `flow spec-validate --strict` 실행 시 1~10번 전체 자동 검증.

### 기존 코드에서 스펙 추출 기준

이미 존재하는 코드베이스에서 스펙을 역으로 추출할 때 사용하는 기준:

**단계 1: 진입점 식별**

| 진입점 유형 | 예시 | 스펙 후보 |
|---|---|---|
| CLI 명령어 | `flow build`, `flow embed` | 각 명령어 = 1개 스펙 후보 |
| API 엔드포인트 | `POST /api/search`, `GET /api/specs` | 각 엔드포인트 그룹 = 1개 스펙 후보 |
| UI 화면/페이지 | 로그인 화면, 대시보드 | 각 화면 = 1개 스펙 후보 |
| 이벤트 핸들러 | 파일 변경 감지, 스케줄 실행 | 각 이벤트 = 1개 스펙 후보 |

**단계 2: 스펙보다 작은 것 걸러내기**

다음은 스펙이 **아니다**. 무시하거나 상위 스펙의 구현 세부사항으로 취급:

- 유틸리티 클래스 (StringHelper, PathUtils)
- 내부 리팩토링 (패턴 변경, 폴더 이동)
- 설정 파일 구조 변경
- 로깅 추가

**단계 3: 스펙보다 큰 것 분할하기**

다음 징후가 보이면 하위 스펙으로 분할:

- 수락 조건이 7개 초과
- "그리고" 로 연결되는 별개 기능이 포함됨
- 구현 예상 시간이 2주 초과
- 담당자가 2명 이상 필요

**단계 4: 계층 구성**

```text
F-001: 사용자 인증 시스템              ← 상위 스펙 (그룹핑 용도)
  ├─ F-010: 로그인 (P1)                 ← 하위 스펙 (실제 구현 단위)
  ├─ F-011: 비밀번호 재설정 (P2)
  └─ F-012: OAuth 연동 (P3)
```

상위 스펙은 직접 구현하지 않는다. 하위 스펙의 상태를 집계하는 역할만 한다.

**단계 5: 의존성 식별**

| 관계 | 의미 | 예시 |
|---|---|---|
| `parent` | 계층 그룹핑 | F-010의 parent = F-001 |
| `dependencies` | "이게 있어야 나도 동작" | F-012는 F-010에 의존 (로그인 있어야 OAuth 의미) |

팁: 기존 코드에서 `import`/`using` 관계, 서비스 호출 관계를 추적하면 의존성을 발견할 수 있다.

### 프로젝트 원칙 (Constitution)

모든 스펙과 구현이 준수해야 하는 프로젝트 수준의 불변 원칙:

| 원칙 | 내용 |
|---|---|
| **I. Library-First** | 모든 기능은 독립 라이브러리로 시작. spec-core가 UI 무관 독립 동작 |
| **II. CLI Interface** | 모든 라이브러리는 CLI로 노출. `flow spec` 명령어 체계 |
| **III. Test-First** | TDD: 테스트 작성 → 실패 확인 → 구현 → 통과 |
| **IV. Simplicity** | YAGNI 원칙. 필요할 때만 복잡도 추가 |
| **V. Spec-Driven** | 코드 변경 전 스펙 먼저, 스펙 없는 기능 구현 금지 |

→ 구체적 내용은 `specs/constitution.md`에 별도 관리.

---

# 🔥 1️⃣ 기본 기능 (AI 구현 적합 — 단, 검증 게이트 필수)

> **⚠️ AI 역할 범위 제한 (10️⃣-C 참조)**
> 단일 노드 CRUD는 AI가 잘 수행하나, 수백 개 노드가 얽힌 DAG 구조에서
> 컨텍스트를 잃지 않고 정확한 의존성을 맺는 것은 현재 LLM의 추론 능력으로 100% 보장이 어렵다.
> AI는 **초안 제안자(Proposer)** 로만 활용하고, 의존성 유효성 검사 및 최종 병합은
> 반드시 **기계적 룰(Kahn 알고리즘 등)과 사람의 승인**을 거치도록 한다.

## 1. JSON 스펙 CRUD

* 스펙 생성
* 수정
* 삭제
* id 중복 검사
* parent 존재 여부 검사
* 의존 id 유효성 검사

👉 AI 초안 생성 가능 → **기계적 검증(스키마 검사, 순환 참조 감지) + 사람 승인** 필수

---

## 2. 그래프 생성

입력:

* docs/specs/*.json (추후 Markdown 기반 Front-matter 등 전환 고려)

출력:

* 트리 구조 (Feature → Condition 계층 포함)
* DAG 구조 (의존성 그래프, Condition 노드 간의 미세한 흐름도 표현 가능)

**스펙(Feature)과 조건(Condition)의 분리 렌더링:**
* `nodeType: feature`: 굵은 테두리와 큰 아이콘으로 주요 기능 단위 표현
* `nodeType: condition`: 하위 노드로 연결되어 개별 테스트 단위, 상태(Status), 코드 단위 연결을 세밀하게 표현

AI 가능:

* 그래프 파싱 코드 생성
* 트리 구성
* 순환 참조 감지 → **Kahn 알고리즘(위상 정렬)** 적용
  * in-degree 기반 BFS로 cycle 노드를 정확히 식별
  * 단위 테스트: 정상 DAG, 자기 참조, 2-node cycle, 다중 cycle 케이스 필수
  * cycle 감지 시 관련 노드 목록을 에러 메시지에 포함

---

## 3. 계층 시각화 웹 (VSCode Webview)

기능:

* 트리뷰
* 노드 클릭 시 상세 패널
* evidence 이미지 표시
* codeRefs 링크 표시

기술:

* VSCode Webview API + Svelte (경량) 또는 React
* 그래프 렌더링: **Cytoscape.js** (CoSE 레이아웃)
* 트리 렌더링: 기본 Tree Component

### 대규모 그래프 성능 전략 (수백~수천 노드)

| 전략 | 내용 |
|---|---|
| 가상화 (Virtualization) | 뷰포트 밖 노드는 DOM에서 제거, Cytoscape `viewport` 이벤트 활용 |
| 청크 로딩 | 초기 로드 시 depth ≤ 2만 렌더, 확장 시 추가 fetch |
| 레벨 필터 | depth / tag / status 기준 필터링으로 동시 표시 노드 제한 |
| 캐싱 | 파싱된 그래프 데이터를 `.spec-cache/graph.json`에 캐시, 파일 변경 시 invalidation |
| Web Worker | 그래프 레이아웃 계산을 Worker 스레드로 분리 |

---

## 3-1. 그래프 편집 시스템 (Graph Editing)

그래프 뷰 안에서 스펙을 **직접 추가·변경·삭제**하고, 편집 세션을 관리한다.
JSON 파일을 직접 열지 않아도 모든 스펙 CRUD가 그래프 위에서 완결된다.

### 편집 오퍼레이션

| 동작 | 트리거 | 설명 |
|---|---|---|
| **노드 추가** | 캔버스 우클릭 → "새 스펙", 기존 노드 우클릭 → "하위 스펙 추가" | ID 자동 채번, 최소 필드(`id`, `title`, `status=draft`) 입력 후 노드 생성 |
| **노드 편집** | 노드 더블클릭 → 인라인 편집 패널 | title, description, status, conditions, tags 등 수정. 상세 패널에서 전체 필드 편집 |
| **노드 삭제** | 노드 우클릭 → "삭제" | 삭제 전 의존성 경고 표시 (이 노드를 참조하는 스펙 목록). 확인 후 soft-delete |
| **의존성 연결** | 노드 A에서 노드 B로 드래그 | A → B 의존성 엣지 생성. 순환 참조 실시간 감지 — cycle 형성 시 엣지 거부 + 경고 |
| **의존성 제거** | 엣지 우클릭 → "연결 해제" | dependencies 배열에서 해당 ID 제거 |
| **노드 이동 (parent 변경)** | 노드를 다른 부모 노드 위로 드래그 & 드롭 | parent 값 변경, 하위 트리 재배치 |

### 편집 세션 모델 (Edit Session)

그래프 편집은 **세션 단위**로 동작한다. 여러 변경을 모은 뒤 한 번에 저장하거나 전체 취소할 수 있다.

```text
[그래프 뷰 진입]
  → 편집 모드 활성화 (상단 배너: "편집 중 — 저장되지 않은 변경 N건")
  → 사용자가 노드 추가 / 수정 / 삭제 / 엣지 변경 수행
  → 변경 사항은 메모리 내 draft 상태로 유지 (파일 미기록)
  → [저장] 클릭 시:
      1. 유효성 검사 (순환 참조, 필수 필드, 참조 무결성)
      2. 검사 통과 → JSON 파일에 일괄 기록 + updatedAt 갱신
      3. 검사 실패 → 오류 목록 표시, 수정 유도 (저장 차단)
  → [취소] 클릭 시:
      모든 draft 변경 폐기, 마지막 저장 상태로 복원
```

**핵심 규칙:**
- 저장 전까지 `docs/specs/*.json` 파일은 변경되지 않음 (안전)
- 편집 중 다른 사용자/프로세스가 파일을 변경하면 **충돌 감지** → merge 또는 overwrite 선택
- 브라우저/VSCode 비정상 종료 시 draft를 `.spec-cache/draft-session.json`에 자동 저장 (crash recovery)

### 편집 히스토리 (Undo / Redo)

| 기능 | 단축키 | 설명 |
|---|---|---|
| Undo | `Ctrl+Z` | 직전 오퍼레이션 되돌리기 (스택 기반) |
| Redo | `Ctrl+Y` / `Ctrl+Shift+Z` | 되돌린 오퍼레이션 재적용 |
| 히스토리 패널 | 사이드바 탭 | 현재 세션의 모든 오퍼레이션을 시간순 나열, 특정 시점으로 점프 가능 |

**히스토리 구조:**

```jsonc
// 각 오퍼레이션은 역연산 가능한 Command 객체로 기록
{
  "sessionId": "2026-02-28T10:30:00Z",
  "operations": [
    {
      "seq": 1,
      "type": "node-create",       // node-create | node-update | node-delete | edge-create | edge-delete
      "timestamp": "2026-02-28T10:30:05Z",
      "target": "F-013",
      "before": null,               // 생성 전 상태 (null = 신규)
      "after": { "id": "F-013", "title": "알림 기능", "status": "draft" },
      "description": "새 스펙 F-013 추가"
    },
    {
      "seq": 2,
      "type": "edge-create",
      "timestamp": "2026-02-28T10:30:12Z",
      "target": "F-013",
      "before": { "dependencies": [] },
      "after": { "dependencies": ["F-010"] },
      "description": "F-013 → F-010 의존성 추가"
    }
  ]
}
```

- Undo = `after` → `before` 역전환, Redo = `before` → `after` 재적용
- 히스토리 스택 최대 100개 오퍼레이션 (설정 가능)
- 저장(commit) 시 히스토리는 Git 커밋에 대응 — 세션 간 히스토리는 Git history로 추적

### 편집 후 변경 요약

저장 직전에 **변경 요약(Change Summary)** 을 표시:

```text
┌─────────────────────────────────────────┐
│  📝 편집 요약 (저장 전 확인)              │
├─────────────────────────────────────────┤
│  추가: F-013 (알림 기능)                  │
│  수정: F-010 (title 변경, 조건 2개 추가)   │
│  삭제: F-009 (레거시 기능)                 │
│  연결: F-013 → F-010 의존성 추가           │
│  해제: F-011 → F-003 의존성 제거           │
├─────────────────────────────────────────┤
│  ⚠️ 영향 받는 스펙: F-011, F-012          │
│  ✅ 순환 참조: 없음                       │
│  ✅ 참조 무결성: 통과                     │
├─────────────────────────────────────────┤
│  [저장]  [취소]  [변경 diff 보기]          │
└─────────────────────────────────────────┘
```

---

# 🔥 2️⃣ 중급 기능 (AI가 70~80%)

## 4. 영향 분석

기능:

* 특정 spec 변경 시
* 하위 spec 탐색
* 의존 spec 탐색
* 영향 범위 계산

알고리즘:

* DFS / BFS 기반 전파
* 영향 레벨 계산
* **최대 전파 depth 설정** (기본값 10, 설정 가능) — 무한 전파 방지

AI 충분히 가능.

---

## 5. 상태 전파

예:

```text
F-010 변경됨
→ F-011, F-012 상태 = needs-review
→ F-ROOT computedStatus = partial (집계/표시 전용)
```

이건 그래프 상태 계산 문제.

AI 구현 가능.

---

## 6. 코드 참조 검증

* codeRefs 파일 존재 여부 검사
* Git diff 기반 변경 감지
* 특정 파일 변경 시 관련 spec 표시

### Git diff 오탐지·미탐지 대응

| 문제 | 대응 |
|---|---|
| 파일 이동/이름 변경 미감지 | `git diff --name-status -M` (rename detection) 사용 |
| 경로 정규화 불일치 | 모든 codeRef를 POSIX 경로(`/`)로 정규화, 대소문자 무시 비교 (Windows) |
| diff 범위 밖 변경 | line-range 매칭 + 파일 전체 변경 fallback |
| 바이너리 파일 | codeRef에 line range 없으면 파일 존재만 검증 |
| 엣지 케이스 테스트 | 공백 포함 경로, 한글 경로, symlink, submodule 내 파일 테스트 필수 |

AI 가능하지만:

* Git 연동 설계는 사람이 구조 잡아야 안정적

---

## 7. 구현 순서 결정 (Implementation Ordering)

그래프 편집이 완료(저장)된 후, **의존성 기반으로 구현 순서를 자동 결정**하고, 이후 AI가 이를 최적화한다.

### Phase A: 기계적 순서 결정 (Topological Sort)

저장 직후 자동 실행. 순수 그래프 알고리즘만 사용.

**알고리즘:**
1. 의존성 그래프에서 **위상 정렬** (Kahn 알고리즘) 실행
2. 동일 depth의 노드는 **priority** 순서로 정렬 (`P1` > `P2` > `P3`)
3. priority도 동일하면 **conditions 수** 기준 오름차순 (작은 스펙 먼저)
4. 결과를 **구현 큐(Implementation Queue)** 로 출력

```text
[그래프 저장 완료]
  → 위상 정렬 실행
  → 구현 큐 생성:
      Phase 1: F-001 (의존성 없음, P1)
      Phase 2: F-010, F-020 (F-001에만 의존, P1)
      Phase 3: F-011, F-012 (F-010에 의존, P2)
      Phase 4: F-030 (F-010 + F-020에 의존, P3)
  → 큐를 Webview에 사이드 패널로 표시
```

**출력 형식:**

```jsonc
{
  "generatedAt": "2026-02-28T10:35:00Z",
  "method": "topological",          // topological | ai-optimized
  "phases": [
    {
      "phase": 1,
      "depth": 0,
      "specs": [
        { "id": "F-001", "title": "사용자 인증 시스템", "priority": "P1", "estimatedDays": null }
      ]
    },
    {
      "phase": 2,
      "depth": 1,
      "specs": [
        { "id": "F-010", "title": "로그인", "priority": "P1", "estimatedDays": null },
        { "id": "F-020", "title": "빌드 시스템", "priority": "P1", "estimatedDays": null }
      ]
    }
  ],
  "warnings": []
}
```

### Phase B: AI 최적화 (선택)

사용자가 "AI 순서 최적화" 버튼을 클릭하면 LLM에 컨텍스트를 전달하여 구현 순서를 재조정한다.

**AI가 고려하는 추가 요소:**

| 요소 | 설명 | 예시 |
|---|---|---|
| 기술적 위험도 | 불확실한 기술 스택 사용 여부 | "Unity AR 연동" → 먼저 PoC |
| 학습 곡선 | 새로운 라이브러리/패턴 도입 | 새 프레임워크 → 앞으로 당기기 (빠른 피드백) |
| 비즈니스 가치 | 사용자 임팩트 크기 | 핵심 기능 → 우선 선점 |
| 병렬 가능성 | 독립된 스펙 동시 구현 | F-010과 F-020이 독립 → 병렬 제안 |
| 테스트 인프라 | 테스트 환경 준비 상태 | CI가 없는 플랫폼 → 인프라 먼저 |
| 기존 코드 참조 밀도 | codeRefs가 이미 많은 스펙 | 부분 구현됨 → 완성에 집중 |

**AI 최적화 플로우:**

```text
[사용자: "AI 순서 최적화" 클릭]
  → 현재 topological 순서 + 전체 스펙 컨텍스트를 LLM에 전달
  → LLM이 재조정된 순서 + 근거(reasoning) 반환
  → 기계적 순서와 AI 순서를 나란히 비교 표시:
      ┌─────────────────┬─────────────────┐
      │ 기계적 순서       │ AI 최적화 순서   │
      ├─────────────────┼─────────────────┤
      │ 1. F-001 (P1)   │ 1. F-001 (P1)   │
      │ 2. F-010 (P1)   │ 2. F-020 (P1) ⬆ │  ← 빌드 인프라 먼저
      │ 3. F-020 (P1)   │ 3. F-010 (P1) ⬇ │
      │ 4. F-011 (P2)   │ 4. F-012 (P2) ⬆ │  ← 기술 위험 조기 해소
      │ 5. F-012 (P2)   │ 5. F-011 (P2) ⬇ │
      └─────────────────┴─────────────────┘
  → 사용자가 AI 순서를 [수락] / [수정] / [무시] 선택
```

**제약:**
- AI 순서는 **의존성 제약을 절대 위반할 수 없음** — LLM이 제안해도 cycle이 생기거나 선행 의존이 깨지면 자동 거부
- AI 근거(reasoning)는 각 변경에 대해 1줄 이상 표시 — 블랙박스 방지
- AI 최적화 결과는 `docs/specs/.ordering/latest.json`에 저장, Git 추적 가능

### CLI 지원

```bash
# 기계적 순서 출력
flow spec-order

# AI 최적화 순서 출력 (LLM 호출)
flow spec-order --ai

# 특정 스펙만 기준으로 부분 순서
flow spec-order --from F-010

# JSON 출력
flow spec-order --output .spec-cache/order.json --pretty
```

---

# 🔥 3️⃣ 고급 기능 (AI 50~60%)

## 7. 코드 → 스펙 자동 추론

예:

* 새 파일 추가됨
* 기존 spec과 매칭 시도
* 없으면 "신규 기능 후보" 제안

이건 LLM 도움 필요.

가능하지만 정확도는 구조에 따라 다름.

---

## 8. 상위 스펙 수정 → 하위 자동 수정

이건 위험합니다.

AI는:

* 변경점 분석
* 하위 스펙 수정 제안

까지는 가능.

하지만 자동 수정은 사람 승인 필요.

---

## 9. 동작 증거 자동 수집

예:

* Unity CLI 실행
* Screenshot 생성
* 로그 저장
* FPS 측정 기록
* Android 면 adb 사용.
* Windows면 파워셸 활용

### 플랫폼별 환경 의존성 대응

| 플랫폼 | 도구 | CI 대응 |
|---|---|---|
| Android | adb | Docker + Android SDK 이미지, `ANDROID_HOME` 환경변수 검증 후 실행 |
| Windows | PowerShell | GitHub Actions `windows-latest` runner, PowerShell 7+ 고정 |
| Unity | Unity CLI | Unity Batch Mode + 라이선스 서버, 없으면 skip + warning |
| 공통 | - | 각 도구 사전 검사(`which`/`Get-Command`), 없으면 graceful skip + 로그 |

* 증거 수집은 **선택적(optional)** 단계로 설계 — 도구 부재 시 스펙 자체 기능에 영향 없음
* CI 매트릭스에 플랫폼별 증거 수집 job 분리 운영

---

# 🔥 4️⃣ 위험 영역 (지금은 비추)

## 완전 자동 리팩토링

상위 spec 변경
→ 하위 코드 자동 수정
→ 자동 빌드
→ 자동 통과

### 안전 게이트 설계 (필수)

```text
[스펙 변경 감지]
  → [영향 범위 계산]
  → [변경 예측 리포트 생성] ← dry-run, diff preview
  → [PR 자동 생성] ← draft PR, 변경 파일 목록 + 영향 스펙 목록 첨부
  → [사람 리뷰 + 승인] ← CODEOWNERS 기반 필수 리뷰어 지정
  → [CI 빌드 + 테스트 통과]
  → [머지]
```

* **자동 코드 수정은 절대 main/develop 브랜치에 직접 push 금지**
* 모든 자동 수정은 `spec-auto/{spec-id}` 브랜치에서 수행
* PR description에 영향받는 스펙 목록 자동 첨부
* 실패 시 롤백: 브랜치 삭제만으로 원상복구 (저장소 손상 없음)

## 먼저 변경 사항을 예측 해서 사용자에게 승인을 받고 진행

---

# ⚠️ 5️⃣ 위험 요소 및 대응 방안

## R1. 자동 코드 수정 시 저장소 손상

| 항목 | 내용 |
|---|---|
| **위험** | Phase 4 자동 리팩토링 실패 시 main 브랜치 손상 |
| **대응** | PR 기반 사람 승인 게이트 필수 유지 (위 4️⃣ 안전 게이트 참조) |
| **추가** | draft PR + CI green 필수 조건, CODEOWNERS 리뷰어 2인 이상 |

## R2. 순환 참조 감지 알고리즘 오류

| 항목 | 내용 |
|---|---|
| **위험** | cycle 미감지 시 그래프 파싱 무한루프 또는 전체 실패 |
| **대응** | Kahn 알고리즘(위상 정렬) 적용 — 남은 노드 = cycle 노드 |
| **테스트** | 정상 DAG / 자기 참조 / 2-node cycle / N-node cycle / 다중 독립 cycle / 빈 그래프 |
| **추가** | cycle 감지 시 관련 노드 ID 목록 출력, `--strict` 모드에서 cycle 존재 시 exit 1 |

## R3. 대규모 그래프 렌더링 성능 저하

| 항목 | 내용 |
|---|---|
| **위험** | 수백~수천 노드 시 웹 UI 프레임 드롭, 메모리 초과 |
| **대응** | 가상화 + 청크 로딩 + Web Worker (위 3번 성능 전략 참조) |
| **벤치마크** | 500 / 1000 / 5000 노드 기준 렌더링 시간 측정 자동화 |
| **임계치** | 초기 렌더 2초 이내, 인터랙션 응답 100ms 이내 |

## R4. Git diff 코드 참조 검증 오탐지·미탐지

| 항목 | 내용 |
|---|---|
| **위험** | 파일 이동, 경로 대소문자, 특수문자 경로에서 매칭 실패 |
| **대응** | 경로 정규화(POSIX, lowercase), rename detection, 위 6번 대응표 참조 |
| **테스트** | 공백 경로, 한글 경로, symlink, 파일 이동, 이름 변경 시나리오 |

## R5. 플랫폼별 증거 수집 CI 실패

| 항목 | 내용 |
|---|---|
| **위험** | adb/Unity CLI/PowerShell 미설치 환경에서 CI 파이프라인 전체 실패 |
| **대응** | 증거 수집을 선택적(optional) 단계로 설계, 도구 사전 검사 후 graceful skip |
| **추가** | CI 매트릭스에서 증거 수집 job 분리, `continue-on-error: true` 적용 |

## R6. 스펙 JSON 스키마 변경 시 데이터 마이그레이션

| 항목 | 내용 |
|---|---|
| **위험** | 스키마 변경 후 기존 스펙 파일 파싱 실패, 데이터 유실 |
| **대응** | `schemaVersion` 필드 필수 포함, 마이그레이션 스크립트 + 자동 백업 |
| **전략** | 위 0️⃣ 스키마 버전 관리 전략 참조 |
| **원칙** | 하위 호환 변경 우선, 파괴적 변경 시 최소 1세대 읽기 어댑터 유지 |

## R7. 웹 UI 보안 — 인증·권한 미구현

| 항목 | 내용 |
|---|---|
| **위험** | 스펙 그래프 웹 UI 외부 노출 시 내부 기능 구조 정보 유출 |
| **대응 (Phase 1)** | VSCode Webview 내에서만 동작 — 외부 접근 불가, 별도 인증 불필요 |
| **대응 (Phase 2, 웹 서버 배포 시)** | OAuth2 / SSO 연동, JWT 토큰 기반 세션 관리 |
| **권한 모델** | viewer (읽기) / editor (수정) / admin (스키마 변경, 삭제) |
| **TTL** | 세션 토큰 TTL 기본 8시간, refresh token 7일, 관리자 설정 가능 |
| **추가** | 모든 수정 API에 audit log 기록 (who, when, what) |

## R9. 그래프 편집 세션 데이터 유실

| 항목 | 내용 |
|---|---|
| **위험** | 편집 중 비정상 종료(crash, 전원 차단) 시 미저장 변경 유실 |
| **대응** | 오퍼레이션마다 `.spec-cache/draft-session.json`에 자동 저장 (crash recovery) |
| **복구** | 재진입 시 "미저장 편집이 있습니다" 알림 → 복원 / 폐기 선택 |
| **충돌** | 외부 파일 변경 감지 시 3-way merge 또는 overwrite 선택 UI 제공 |
| **테스트** | 50건 편집 후 강제 종료 → 복원 시나리오, 동시 외부 변경 충돌 시나리오 |

## R8. 테스트 데이터 노후화 및 신뢰성

| 항목 | 내용 |
|---|---|
| **위험** | 테스트 결과가 스펙에 동기화되지 않으면 `testSummary`가 실제와 괴리되어 잘못된 확신(false confidence) 제공 |
| **대응** | CI에서 `flow spec-test-sync`를 필수 단계로 설정, PR merge 전 자동 동기화 |
| **freshness 검증** | `lastRun.executedAt`가 30일 이상 경과된 테스트는 `stale` 배지 표시 |
| **미해결 실패 추적** | `lastFailure.resolvedAt = null`인 테스트 목록을 `flow spec-test-report`에 별도 섹션으로 표시 |
| **테스트 누락 방지** | `--strict --check-tests` 옵션으로 테스트 없는 조건 감지 |
| **Flaky 대응** | `flakyScore ≥ 0.1` 시 자동 quarantine + 경고, CI에서 별도 job 실행 |
| **history 무결성** | 테스트 삭제/이름 변경 시 history 초기화 정책 명시 (기본: 보존 + 경고) |

---

# 🔥 6️⃣ 추가 보완 사항

## F1. 테스트 전략

### 테스트 계층 및 도구

| 레벨 | 범위 | 도구 | 스펙 연결 |
|---|---|---|---|
| Unit | 스키마 검증, 순환 참조 감지, 영향 분석 알고리즘 | xUnit / Jest | `conditions[].tests` (각 조건별 단위 테스트) |
| Integration | CLI CRUD → 파일 시스템, Git diff 파싱, DB 연동 | xUnit + temp git repo | `tests` (기능 수준 통합 테스트) |
| E2E | CLI 전체 플로우, VSCode Extension 로드 → Webview 렌더링 → 노드 클릭 | @vscode/test-electron, pytest | `e2eScenarios` |
| Performance | N-node 그래프 렌더링 벤치마크 | custom benchmark script | `tests` (type: `performance`) |

### 테스트 데이터 자동 수집 파이프라인

```text
[테스트 실행 (CI/local)]
  → [xUnit/Jest 결과 JSON 출력]
  → [flow spec-test-sync] ← 결과 파싱 + 스펙 매핑
  → [tests[].lastRun 갱신]
  → [lastFailure 갱신 (실패 시)]
  → [history 누적 통계 재계산]
  → [testSummary 자동 집계]
  → [healthScore / flakyScore 계산]
  → [trend 판정 (최근 5회 기준)]
```

### 테스트 실행 매핑 규칙

테스트 코드 내 어노테이션으로 스펙과 자동 매핑:

```csharp
// xUnit 예시
[Fact]
[Trait("Spec", "F-010-C1")]  // ← 스펙 조건 ID 매핑
[Trait("TestId", "F-010-C1-T1")]
public void Login_WithValidCredentials_ReturnsToken() { ... }
```

```python
# pytest 예시
@pytest.mark.spec("F-010-E2E-1")  # ← E2E 시나리오 매핑
def test_full_login_flow(): ...
```

`flow spec-test-sync` 명령이 어노테이션을 파싱하여 스펙 JSON의 `tests` / `e2eScenarios`에 자동 연결.

### 테스트 건강도 지표 (Health Score)

| 지표 | 계산 | 임계치 |
|---|---|---|
| `healthScore` | `(passed - flakyPenalty) / total` | ≥ 0.8 정상, < 0.6 위험 |
| `flakyScore` | `failCount / totalRuns` (개별 테스트) | ≥ 0.1 이면 flaky 판정 |
| `trend` | 최근 5회 `passed` 비율 추세 | 하락 시 `degrading` 경고 |
| `coverage` | CI 커버리지 연동 | ≥ 70% 권장, < 50% warning |

### Flaky 테스트 관리 정칙

| 단계 | 기준 | 조치 |
|---|---|---|
| 감지 | `flakyScore ≥ 0.1` | `testSummary.flakyTests`에 ID 등록 |
| 경고 | 연속 3회 flaky | CLI warning + Webview 배지 표시 |
| 격리 | 연속 5회 flaky | CI에서 `[Trait("Quarantine", "true")]` 자동 태그, 별도 job 실행 |
| 해결 | 수정 후 5회 연속 pass | quarantine 해제, `flakyScore` 리셋 |

### 테스트 실패 상세 추적

`lastFailure`가 `resolvedAt = null`인 테스트는 **미해결 실패**로 분류:

```text
flow spec-test-report
┌─────────────┬────────────┬─────────────────┬───────────────────────────────────┐
│ Spec         │ Health     │ Failed Tests    │ Unresolved Failures               │
├─────────────┼────────────┼─────────────────┼───────────────────────────────────┤
│ F-010        │ 0.92 ✅    │ 0/8             │ -                                 │
│ F-011        │ 0.75 ⚠️    │ 1/6             │ F-011-C2-T1 (2026-02-27, 미해결)  │
│ F-020        │ 0.50 ❌    │ 3/10            │ F-020-C1-T2, F-020-E2E-1          │
└─────────────┴────────────┴─────────────────┴───────────────────────────────────┘
```

### CI/CD 테스트 연동

```yaml
# .github/workflows/spec-test-sync.yml
on: [push, pull_request]
jobs:
  test-and-sync:
    steps:
      - run: dotnet test --logger "json;LogFilePath=test-results.json"
      - run: flow spec-test-sync --from test-results.json  # 테스트 결과 → 스펙 동기화
      - run: flow spec-test-report --format markdown >> $GITHUB_STEP_SUMMARY
      - run: flow spec-validate --strict --check-tests     # 테스트 연결 검증 포함
```

## F2. 네이밍 컨벤션

* 스펙 ID: `F-{3자리 숫자}` (예: `F-001`, `F-042`)
* 하위 기능: `F-{부모번호}-{2자리}` (예: `F-010-01`)
* 파일명: `{id}.json` (예: `F-010.json`)
* 폴더 구조: `docs/specs/` (flat), evidence는 `docs/evidence/{id}/`

## F3. 백업 및 복구

* 스펙 파일은 Git 관리 대상 → Git history가 곧 백업
* 마이그레이션 전 자동 스냅샷: `docs/specs/.backup/{timestamp}/`
* `flow spec-restore <timestamp>` 명령으로 복구

## F4. CI/CD 통합

```yaml
# .github/workflows/spec-validate.yml
on: [push, pull_request]
jobs:
  spec-lint:
    steps:
      - run: flow spec-validate --strict --check-tests  # 스키마 + 순환 참조 + orphan + 테스트 연결 검사
      - run: flow spec-check-refs                       # codeRefs 파일 존재 검증
  spec-graph:
    steps:
      - run: flow spec-graph --output .spec-cache/graph.json
  spec-test-sync:
    needs: [spec-lint]
    steps:
      - run: dotnet test --logger "json;LogFilePath=test-results.json"
      - run: flow spec-test-sync --from test-results.json
      - run: flow spec-test-report --format markdown >> $GITHUB_STEP_SUMMARY
```

## F5. Spec 변경 이력 추적

* 모든 스펙 수정 시 `updatedAt` 자동 갱신
* `flow spec-log {id}` → Git log에서 해당 파일 변경 이력 추출 (계획)
* PR에 변경된 스펙 ID 자동 라벨링 (GitHub Actions)

## F6. 에러 핸들링 정책

| 상황 | 동작 |
|---|---|
| 스펙 파일 JSON 파싱 실패 | 해당 노드 skip + warning, 나머지 그래프 정상 구성 |
| 존재하지 않는 parent 참조 | 유효성 검사에서 에러, CLI exit 1 |
| codeRef 파일 미존재 | warning 표시, `--strict` 모드에서는 에러 |
| schemaVersion 불일치 | 마이그레이션 안내 메시지 출력, 읽기는 시도 |
| 테스트 결과 파일 파싱 실패 | 해당 테스트 skip + warning, `lastRun` 미갱신 |
| 테스트 어노테이션 매핑 실패 | 매핑 못한 테스트 목록 출력, 수동 매핑 안내 |
| `lastFailure.resolvedAt` 미설정 | 미해결 실패로 분류, 리포트에 별도 표시 |

## F7. 스펙 자동 동기화 트리거 (Hooks & Instructions)

스펙 그래프의 최대 위험은 **코드와 스펙의 괴리(D1, D2 참조)**이다.
이를 방지하려면 개발자가 수동으로 `flow spec-*`을 실행하지 않아도 **자동으로 스펙이 동기화**되는 트리거를 여러 계층에 설치해야 한다.

### 트리거 계층 개요

```text
┌─────────────────────────────────────────────────────────────────────┐
│                     스펙 자동 동기화 트리거 계층                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Layer 1: Git Hooks (로컬, 즉시)                                     │
│    ├─ pre-commit   → 변경된 파일이 어떤 스펙의 codeRef에 해당하는지 알림  │
│    ├─ post-commit  → 스펙 그래프 캐시 자동 갱신                        │
│    └─ pre-push     → spec-validate 실행, 실패 시 push 차단            │
│                                                                     │
│  Layer 2: CI/CD (원격, push/PR 시)                                   │
│    ├─ GitHub Actions on push    → spec-validate + spec-check-refs   │
│    ├─ GitHub Actions on PR      → 변경 스펙 자동 라벨링 + 리포트       │
│    └─ GitHub Actions scheduled  → stale 스펙 감지 + 알림             │
│                                                                     │
│  Layer 3: VSCode Extension (에디터, 실시간)                           │
│    ├─ onDidSaveTextDocument → 저장 시 관련 스펙 표시                   │
│    ├─ FileSystemWatcher     → docs/specs/ 변경 감지 → 그래프 자동 갱신 │
│    └─ onDidChangeActiveTextEditor → 현재 파일 관련 스펙 사이드바 표시   │
│                                                                     │
│  Layer 4: AI Agent Instructions (프롬프트 입력 시)                    │
│    ├─ Copilot Custom Instructions → 코드 변경 시 스펙 동기화 지시      │
│    ├─ .github/agents/*.md         → 에이전트 워크플로우에 스펙 단계 삽입│
│    └─ Copilot Skills              → 스펙 관련 작업 자동 트리거         │
│                                                                     │
│  Layer 5: Copilot Agent Hooks (에이전트 세션 중, 프로그래밍 방식)       │
│    ├─ postToolUse   → 파일 편집/생성 후 자동 spec-check-refs 실행      │
│    ├─ sessionEnd    → 세션 종료 시 spec-validate 전체 검증             │
│    ├─ preToolUse    → 스펙 파일 직접 수정 시 유효성 사전 검사           │
│    └─ userPromptSubmitted → 프롬프트 로깅 + 스펙 관련 키워드 감지       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### Layer 1: Git Hooks (로컬 트리거)

Git hooks를 통해 **커밋/푸시 타이밍**에 스펙 관련 검증과 동기화를 자동 실행한다.

#### 설치 방법

프로젝트 루트에 `.githooks/` 폴더를 만들고, `git config core.hooksPath .githooks`로 설정한다.
`install.ps1`에 자동 설정 스크립트를 포함시킨다.

```powershell
# install.ps1에 추가
git config core.hooksPath .githooks
Write-Host "Git hooks configured: .githooks/"
```

#### pre-commit — 코드 변경 시 관련 스펙 알림

커밋 직전에 변경된 파일이 어떤 스펙의 `codeRefs`에 포함되는지 검사하여 알림한다.
스펙 `updatedAt`가 갱신되지 않은 채 코드만 변경되면 **warning**을 표시한다.

```bash
#!/bin/sh
# .githooks/pre-commit

# 변경된 파일 목록 추출
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$CHANGED_FILES" ]; then
  exit 0
fi

# 코드 파일 변경이 있을 때만 스펙 참조 검사
CODE_FILES=$(echo "$CHANGED_FILES" | grep -E '\.(cs|ts|py|dart|js|jsx|tsx)$')
if [ -n "$CODE_FILES" ]; then
  # flow spec-check-refs가 변경 파일과 매칭되는 스펙을 출력
  AFFECTED_SPECS=$(dotnet run --project tools/flow-cli -- spec-check-refs --changed-files $CODE_FILES 2>/dev/null)
  if [ -n "$AFFECTED_SPECS" ]; then
    echo ""
    echo "⚠️  [Spec Graph] 다음 스펙의 codeRef에 해당하는 파일이 변경되었습니다:"
    echo "$AFFECTED_SPECS"
    echo ""
    echo "💡 관련 스펙의 status/updatedAt 갱신을 검토하세요."
    echo "   flow spec-get <ID> 로 확인 가능합니다."
    echo ""
  fi
fi

# 스펙 파일 자체가 변경된 경우 최소 검증
SPEC_FILES=$(echo "$CHANGED_FILES" | grep 'docs/specs/.*\.json$')
if [ -n "$SPEC_FILES" ]; then
  dotnet run --project tools/flow-cli -- spec-validate 2>&1
  if [ $? -ne 0 ]; then
    echo "❌ [Spec Graph] 스펙 유효성 검사 실패. 커밋이 차단됩니다."
    echo "   flow spec-validate 로 상세 오류를 확인하세요."
    exit 1
  fi
fi

exit 0
```

#### post-commit — 그래프 캐시 자동 갱신

커밋 완료 후 백그라운드에서 그래프 캐시를 갱신한다. 차단하지 않으므로 UX에 영향 없다.

```bash
#!/bin/sh
# .githooks/post-commit

# 스펙 파일 변경 여부 확인
SPEC_CHANGED=$(git diff HEAD~1 --name-only | grep 'docs/specs/.*\.json$')
if [ -n "$SPEC_CHANGED" ]; then
  # 백그라운드에서 그래프 캐시 갱신
  nohup dotnet run --project tools/flow-cli -- spec-graph --output .spec-cache/graph.json > /dev/null 2>&1 &
  echo "🔄 [Spec Graph] 그래프 캐시 갱신 중 (백그라운드)"
fi
```

#### pre-push — 원격 push 전 전체 검증

push 직전에 `spec-validate --strict`를 실행하여 잘못된 스펙이 원격에 올라가는 것을 방지한다.

```bash
#!/bin/sh
# .githooks/pre-push

echo "🔍 [Spec Graph] Push 전 스펙 검증 실행 중..."

dotnet run --project tools/flow-cli -- spec-validate --strict 2>&1
VALIDATE_EXIT=$?

dotnet run --project tools/flow-cli -- spec-check-refs 2>&1
REFS_EXIT=$?

if [ $VALIDATE_EXIT -ne 0 ] || [ $REFS_EXIT -ne 0 ]; then
  echo ""
  echo "❌ [Spec Graph] 스펙 검증 실패. Push가 차단됩니다."
  echo "   --no-verify 플래그로 우회할 수 있으나 권장하지 않습니다."
  exit 1
fi

echo "✅ [Spec Graph] 스펙 검증 통과"
exit 0
```

#### PowerShell 버전 (Windows)

Windows 환경에서는 `.githooks/` 대신 PowerShell 기반 hook을 사용한다.

```powershell
# .githooks/pre-commit.ps1 (git config core.hooksPath에서 호출)

$changedFiles = git diff --cached --name-only --diff-filter=ACM
$specFiles = $changedFiles | Where-Object { $_ -match 'docs/specs/.*\.json$' }

if ($specFiles) {
    $result = & dotnet run --project tools/flow-cli -- spec-validate 2>&1
    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ [Spec Graph] 스펙 유효성 검사 실패" -ForegroundColor Red
        Write-Host $result
        exit 1
    }
}

$codeFiles = $changedFiles | Where-Object { $_ -match '\.(cs|ts|py|dart)$' }
if ($codeFiles) {
    $affected = & dotnet run --project tools/flow-cli -- spec-check-refs --changed-files ($codeFiles -join ',') 2>&1
    if ($affected) {
        Write-Host ""
        Write-Host "⚠️  [Spec Graph] 관련 스펙이 영향받을 수 있습니다:" -ForegroundColor Yellow
        Write-Host $affected
    }
}

exit 0
```

---

### Layer 2: CI/CD (GitHub Actions 트리거)

원격 저장소에 push/PR이 발생할 때 CI에서 스펙 그래프를 자동으로 검증하고 동기화한다.

#### Push 시 스펙 검증 + 그래프 갱신

```yaml
# .github/workflows/spec-sync.yml
name: Spec Graph Sync

on:
  push:
    paths:
      - 'docs/specs/**'
      - 'tools/**'
      - '*.cs'
      - '*.ts'
      - '*.py'

jobs:
  spec-validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Validate specs
        run: dotnet run --project tools/flow-cli -- spec-validate --strict

      - name: Check code references
        run: dotnet run --project tools/flow-cli -- spec-check-refs

      - name: Rebuild graph cache
        run: dotnet run --project tools/flow-cli -- spec-graph --output .spec-cache/graph.json

      - name: Detect stale specs
        run: |
          # 코드가 변경되었으나 관련 스펙 updatedAt이 갱신되지 않은 경우 감지
          CHANGED=$(git diff HEAD~1 --name-only | grep -E '\.(cs|ts|py|dart)$' || true)
          if [ -n "$CHANGED" ]; then
            dotnet run --project tools/flow-cli -- spec-check-refs --changed-files "$CHANGED" --warn-stale
          fi
```

#### PR 시 변경 스펙 자동 라벨링 + 리포트

```yaml
# .github/workflows/spec-pr-report.yml
name: Spec PR Report

on:
  pull_request:
    paths:
      - 'docs/specs/**'
      - 'tools/**'

jobs:
  spec-report:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate spec change report
        id: report
        run: |
          CHANGED_SPECS=$(git diff origin/main --name-only | grep 'docs/specs/.*\.json$' || true)
          if [ -n "$CHANGED_SPECS" ]; then
            echo "## 📊 Spec Graph 변경 리포트" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            for spec in $CHANGED_SPECS; do
              ID=$(basename "$spec" .json)
              echo "- **$ID** 변경됨" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            dotnet run --project tools/flow-cli -- spec-validate --strict >> $GITHUB_STEP_SUMMARY 2>&1 || true
            dotnet run --project tools/flow-cli -- spec-impact $(echo $CHANGED_SPECS | xargs -I{} basename {} .json) >> $GITHUB_STEP_SUMMARY 2>&1 || true
          fi

      - name: Add spec labels
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const changed = execSync('git diff origin/main --name-only').toString()
              .split('\n').filter(f => f.match(/docs\/specs\/.*\.json$/));
            if (changed.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['spec-change']
              });
            }
```

#### 주간 Stale 스펙 감지 (Scheduled)

```yaml
# .github/workflows/spec-stale-check.yml
name: Spec Stale Check

on:
  schedule:
    - cron: '0 9 * * 1'  # 매주 월요일 09:00 UTC

jobs:
  stale-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Find stale specs
        run: |
          echo "## 📋 주간 Stale 스펙 리포트" >> $GITHUB_STEP_SUMMARY
          # updatedAt이 30일 이상 경과된 스펙 탐지
          dotnet run --project tools/flow-cli -- spec-list --stale-days 30 >> $GITHUB_STEP_SUMMARY 2>&1 || true
```

---

### Layer 3: VSCode Extension Hooks (에디터 실시간 트리거)

VSCode Extension에서 파일 이벤트를 감지하여 스펙 그래프를 실시간으로 동기화한다.

#### 파일 저장 시 관련 스펙 자동 표시

```typescript
// tools/spec-graph-ext/src/extension.ts 에 추가

import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  // 파일 저장 시 관련 스펙 알림
  const onSave = vscode.workspace.onDidSaveTextDocument(async (doc) => {
    const filePath = vscode.workspace.asRelativePath(doc.uri);

    // 코드 파일인 경우에만 스펙 참조 검사
    if (filePath.match(/\.(cs|ts|py|dart|js|jsx|tsx)$/)) {
      const terminal = vscode.window.createTerminal({ name: 'Spec Check', hideFromUser: true });
      // spec-check-refs --changed-files로 관련 스펙 확인
      const result = await execSpecCommand(`spec-check-refs --changed-files "${filePath}"`);
      if (result && result.trim()) {
        vscode.window.showInformationMessage(
          `📊 이 파일이 영향받는 스펙: ${result.trim()}`,
          '스펙 열기', '무시'
        ).then(selection => {
          if (selection === '스펙 열기') {
            // 관련 스펙 파일을 에디터에서 열기
            const specId = result.trim().split(',')[0];
            vscode.workspace.openTextDocument(`docs/specs/${specId}.json`);
          }
        });
      }
    }

    // 스펙 파일 저장 시 그래프 자동 갱신
    if (filePath.match(/docs\/specs\/.*\.json$/)) {
      await execSpecCommand('spec-validate');
      await execSpecCommand('spec-graph --output .spec-cache/graph.json');
      specGraphView.refresh();  // Webview 자동 새로고침
    }
  });

  // docs/specs/ 폴더 감시 — 외부 변경(Git pull 등)도 감지
  const watcher = vscode.workspace.createFileSystemWatcher('**/docs/specs/*.json');
  watcher.onDidChange(() => specGraphView.refresh());
  watcher.onDidCreate(() => specGraphView.refresh());
  watcher.onDidDelete(() => specGraphView.refresh());

  // 활성 에디터 변경 시 관련 스펙 사이드바 하이라이트
  const onEditorChange = vscode.window.onDidChangeActiveTextEditor(async (editor) => {
    if (editor) {
      const filePath = vscode.workspace.asRelativePath(editor.document.uri);
      await specTreeView.highlightRelatedSpecs(filePath);
    }
  });

  context.subscriptions.push(onSave, watcher, onEditorChange);
}
```

#### VSCode Task로 자동 스펙 검증

`.vscode/tasks.json`에 스펙 관련 작업을 등록하여 단축키로 실행하거나, 빌드 후 자동 실행하도록 한다.

```jsonc
// .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Spec: Validate",
      "type": "shell",
      "command": "./flow.ps1 spec-validate --strict",
      "group": "test",
      "problemMatcher": [],
      "runOptions": {
        "runOn": "folderOpen"  // 폴더 열 때 자동 실행 (선택)
      }
    },
    {
      "label": "Spec: Graph Rebuild",
      "type": "shell",
      "command": "./flow.ps1 spec-graph --output .spec-cache/graph.json",
      "group": "build",
      "dependsOn": ["Spec: Validate"]
    },
    {
      "label": "Spec: Check Refs",
      "type": "shell",
      "command": "./flow.ps1 spec-check-refs",
      "group": "test"
    }
  ]
}
```

---

### Layer 4: AI Agent Instructions (프롬프트 트리거)

Copilot 에이전트나 AI 코딩 보조에게 **코드를 변경할 때마다 스펙 동기화를 고려하도록** 지시한다.
이를 통해 사용자가 프롬프트를 입력하여 코드 변경을 요청하면, AI가 자동으로 관련 스펙 업데이트도 함께 수행한다.

#### 방법 1: Copilot Custom Instructions (`.github/copilot-instructions.md`)

GitHub Copilot이 모든 프롬프트에서 참조하는 프로젝트 수준 지시 파일이다.
이 파일에 스펙 동기화 규칙을 추가하면, Copilot이 코드 변경 시 자동으로 스펙 업데이트를 제안한다.

```markdown
<!-- .github/copilot-instructions.md에 추가 -->

## Spec Graph 동기화 규칙

이 프로젝트는 JSON 기반 스펙 그래프(`docs/specs/*.json`)로 기능을 관리합니다.

### 코드 변경 시 필수 확인 사항
1. 변경하는 코드가 기존 스펙의 `codeRefs`에 포함되어 있는지 확인
2. 포함된 경우: 해당 스펙의 `updatedAt`을 현재 시각으로 갱신
3. 새 기능을 추가하는 경우: `flow spec-create`로 새 스펙 생성을 제안
4. 기존 기능을 삭제하는 경우: 관련 스펙의 `status`를 `deprecated`로 변경

### 변경 완료 후 검증
- `./flow.ps1 spec-validate` 실행하여 스펙 유효성 확인
- `./flow.ps1 spec-check-refs` 실행하여 코드 참조 유효성 확인

### 스펙 수정 규칙
- 스펙 파일은 `docs/specs/` 아래 `{id}.json` 형태
- 스펙 ID 형식: `F-{3자리 숫자}` (예: F-010)
- 스펙 관련 CLI: `./flow.ps1 spec-*` 참조
```

#### 방법 2: GitHub Copilot Agent (`/.github/agents/*.md`)

기존 `flow.agent.md`의 워크플로우에 스펙 동기화 단계를 삽입한다.
에이전트가 코드 구현을 완료한 후 자동으로 관련 스펙을 갱신하는 흐름을 강제한다.

```markdown
<!-- .github/agents/flow.agent.md에 스펙 동기화 단계 추가 -->

## 구현 완료 후 스펙 동기화 (필수)

코드 구현이 완료되면 반드시 다음 단계를 수행한다:

1. **영향 스펙 확인**: `./flow.ps1 spec-check-refs`로 변경 파일이 참조하는 스펙 확인
2. **스펙 상태 갱신**: 구현 완료된 조건(condition)의 status를 `verified`로 변경
3. **updatedAt 갱신**: 수정된 스펙의 `updatedAt`을 현재 시각으로 갱신
4. **검증 실행**: `./flow.ps1 spec-validate --strict` 통과 확인
5. **그래프 갱신**: `./flow.ps1 spec-graph --output .spec-cache/graph.json`

이 단계를 건너뛰면 스펙 그래프가 stale 상태가 되어 프로젝트 추적이 부정확해진다.
```

#### 방법 3: Copilot Skills (`.github/skills/`)

기존 `flow-spec-graph` skill에 자동 동기화 트리거 가이드를 포함시킨다.
Copilot이 스펙 관련 작업을 수행할 때 자동으로 이 skill을 로드한다.

```markdown
<!-- .github/skills/flow-spec-graph/SKILL.md에 추가 -->

## 자동 동기화 체크리스트

코드를 변경할 때 아래 체크리스트를 자동으로 실행:
- [ ] `spec-check-refs`로 영향 스펙 확인
- [ ] 영향받는 스펙의 `updatedAt` 갱신
- [ ] 새 기능이면 `spec-create` 실행
- [ ] `spec-validate --strict` 통과 확인
```

#### 방법 4: VS Code Settings — Copilot Chat Participant 설정

VS Code 설정에서 Copilot에게 항상 스펙을 고려하도록 지시한다.

```jsonc
// .vscode/settings.json
{
  "github.copilot.chat.codeGeneration.instructions": [
    {
      "text": "이 프로젝트는 docs/specs/*.json에 기능 스펙을 관리합니다. 코드를 생성하거나 수정할 때 관련 스펙의 codeRefs와 status를 함께 업데이트하세요. 작업 완료 후 ./flow.ps1 spec-validate를 실행하세요."
    }
  ]
}
```

---

### Layer 5: Copilot Agent Hooks (에이전트 세션 트리거)

GitHub Copilot Coding Agent와 Copilot CLI는 `.github/hooks/*.json`에 정의된 **셸 스크립트를 에이전트 실행 흐름의 핵심 시점마다 자동 실행**하는 Hooks 메커니즘을 지원한다.

Layer 4(Instructions)가 AI에게 "해라"고 **텍스트로 지시**하는 방식이라면, Layer 5(Hooks)는 **프로그래밍 방식으로 셸 커맨드를 강제 실행**하는 메커니즘이다. AI가 지시를 무시하거나 잊어버릴 가능성이 없으므로 **가장 확실한 스펙 동기화 보장 수단**이다.

> **참고**: [GitHub Docs — About hooks](https://docs.github.com/en/copilot/concepts/agents/coding-agent/about-hooks) · [Hooks configuration](https://docs.github.com/en/copilot/reference/hooks-configuration)

#### 사용 가능한 Hook 타입

| Hook | 실행 시점 | 스펙 동기화 활용 |
|---|---|---|
| `sessionStart` | 에이전트 세션 시작/재개 시 | 현재 스펙 상태 스냅샷 저장, 그래프 캐시 로드 |
| `userPromptSubmitted` | 사용자 프롬프트 제출 시 | 프롬프트 로깅, 스펙 관련 키워드("기능 추가", "삭제") 감지 → 알림 |
| `preToolUse` | 도구(bash/edit/create) 실행 직전 | 스펙 파일 직접 수정 시 유효성 사전 검사, 위험한 스펙 삭제 차단 |
| `postToolUse` | 도구 실행 완료 후 | 코드 파일 편집/생성 시 영향받는 스펙 자동 감지 + 알림 |
| `sessionEnd` | 에이전트 세션 종료 시 | `spec-validate` 전체 검증 + 그래프 캐시 갱신 |
| `agentStop` | 메인 에이전트 응답 완료 시 | 스펙 변경 요약 리포트 생성 |
| `errorOccurred` | 에이전트 오류 발생 시 | 스펙 관련 오류 로깅 |

#### Hook 설정 파일 — `.github/hooks/spec-sync.json`

```jsonc
{
  "version": 1,
  "hooks": {
    "sessionStart": [
      {
        "type": "command",
        "bash": "./.github/hooks/scripts/spec-session-start.sh",
        "powershell": "./.github/hooks/scripts/spec-session-start.ps1",
        "cwd": ".",
        "timeoutSec": 15,
        "comment": "세션 시작 시 스펙 그래프 상태 스냅샷"
      }
    ],
    "postToolUse": [
      {
        "type": "command",
        "bash": "./.github/hooks/scripts/spec-post-tool.sh",
        "powershell": "./.github/hooks/scripts/spec-post-tool.ps1",
        "cwd": ".",
        "timeoutSec": 10,
        "comment": "파일 편집/생성 후 영향받는 스펙 감지"
      }
    ],
    "preToolUse": [
      {
        "type": "command",
        "bash": "./.github/hooks/scripts/spec-pre-tool.sh",
        "powershell": "./.github/hooks/scripts/spec-pre-tool.ps1",
        "cwd": ".",
        "timeoutSec": 10,
        "comment": "스펙 파일 수정 시 유효성 사전 검사"
      }
    ],
    "sessionEnd": [
      {
        "type": "command",
        "bash": "./.github/hooks/scripts/spec-session-end.sh",
        "powershell": "./.github/hooks/scripts/spec-session-end.ps1",
        "cwd": ".",
        "timeoutSec": 30,
        "comment": "세션 종료 시 전체 스펙 검증 + 그래프 갱신"
      }
    ]
  }
}
```

#### Hook 스크립트 구현

**postToolUse — 코드 파일 편집 후 영향 스펙 자동 감지 (가장 핵심)**

에이전트가 코드를 수정할 때마다 자동으로 실행되어, 해당 파일이 어떤 스펙의 `codeRefs`에 포함되는지 확인한다.

```bash
#!/bin/bash
# .github/hooks/scripts/spec-post-tool.sh
set -e
INPUT=$(cat)
TOOL_NAME=$(echo "$INPUT" | jq -r '.toolName')
RESULT_TYPE=$(echo "$INPUT" | jq -r '.toolResult.resultType')

# edit 또는 create 도구가 성공한 경우에만 검사
if [ "$RESULT_TYPE" != "success" ]; then
  exit 0
fi

if [ "$TOOL_NAME" = "edit" ] || [ "$TOOL_NAME" = "create" ]; then
  # 편집/생성된 파일 경로 추출
  FILE_PATH=$(echo "$INPUT" | jq -r '.toolArgs' | jq -r '.path // .filePath // empty')

  if [ -z "$FILE_PATH" ]; then
    exit 0
  fi

  # 코드 파일인 경우에만 스펙 참조 검사
  if echo "$FILE_PATH" | grep -qE '\.(cs|ts|py|dart|js|jsx|tsx)$'; then
    AFFECTED=$(dotnet run --project tools/flow-cli -- spec-check-refs --changed-files "$FILE_PATH" 2>/dev/null || true)
    if [ -n "$AFFECTED" ]; then
      echo "[Spec Graph] 영향받는 스펙: $AFFECTED" >&2
    fi
  fi

  # 스펙 파일이 수정된 경우 즉시 유효성 검사
  if echo "$FILE_PATH" | grep -qE 'docs/specs/.*\.json$'; then
    VALIDATE_RESULT=$(dotnet run --project tools/flow-cli -- spec-validate 2>&1 || true)
    if echo "$VALIDATE_RESULT" | grep -qi 'error\|fail'; then
      echo "[Spec Graph] ⚠️ 스펙 유효성 검사 경고: $VALIDATE_RESULT" >&2
    fi
  fi
fi
```

```powershell
# .github/hooks/scripts/spec-post-tool.ps1
$ErrorActionPreference = "SilentlyContinue"
$input = [Console]::In.ReadToEnd() | ConvertFrom-Json

if ($input.toolResult.resultType -ne "success") { exit 0 }
if ($input.toolName -notin @("edit", "create")) { exit 0 }

$toolArgs = $input.toolArgs | ConvertFrom-Json
$filePath = $toolArgs.path ?? $toolArgs.filePath
if (-not $filePath) { exit 0 }

# 코드 파일 → 영향 스펙 감지
if ($filePath -match '\.(cs|ts|py|dart|js|jsx|tsx)$') {
    $affected = & dotnet run --project tools/flow-cli -- spec-check-refs --changed-files $filePath 2>$null
    if ($affected) {
        Write-Error "[Spec Graph] 영향받는 스펙: $affected"
    }
}

# 스펙 파일 → 즉시 유효성 검사
if ($filePath -match 'docs/specs/.*\.json$') {
    $result = & dotnet run --project tools/flow-cli -- spec-validate 2>&1
    if ($LASTEXITCODE -ne 0) {
        Write-Error "[Spec Graph] 스펙 유효성 검사 경고: $result"
    }
}

exit 0
```

**preToolUse — 스펙 파일 삭제 차단 (안전장치)**

`preToolUse`는 유일하게 **도구 실행을 차단(deny)** 할 수 있는 hook이다.
스펙 파일의 무분별한 삭제를 방지하는 안전장치로 활용한다.

```bash
#!/bin/bash
# .github/hooks/scripts/spec-pre-tool.sh
set -e
INPUT=$(cat)
TOOL_NAME=$(echo "$INPUT" | jq -r '.toolName')

# bash 명령에서 스펙 파일 삭제 시도 감지
if [ "$TOOL_NAME" = "bash" ]; then
  COMMAND=$(echo "$INPUT" | jq -r '.toolArgs' | jq -r '.command // empty')

  # rm 명령이 docs/specs/ 파일을 대상으로 하는지 검사
  if echo "$COMMAND" | grep -qE 'rm.*docs/specs/.*\.json'; then
    echo '{"permissionDecision":"deny","permissionDecisionReason":"스펙 파일 직접 삭제 금지. flow spec-delete 명령을 사용하세요."}'
    exit 0
  fi
fi

# 그 외는 모두 허용
exit 0
```

```powershell
# .github/hooks/scripts/spec-pre-tool.ps1
$input = [Console]::In.ReadToEnd() | ConvertFrom-Json

if ($input.toolName -eq "bash") {
    $toolArgs = $input.toolArgs | ConvertFrom-Json
    $command = $toolArgs.command

    if ($command -match 'rm.*docs/specs/.*\.json|Remove-Item.*docs[/\\]specs[/\\].*\.json') {
        @{
            permissionDecision = "deny"
            permissionDecisionReason = "스펙 파일 직접 삭제 금지. flow spec-delete 명령을 사용하세요."
        } | ConvertTo-Json -Compress
        exit 0
    }
}

exit 0
```

**sessionEnd — 세션 종료 시 전체 스펙 검증**

에이전트 세션이 끝날 때 모든 스펙의 유효성을 검증하고 그래프 캐시를 갱신한다.

```bash
#!/bin/bash
# .github/hooks/scripts/spec-session-end.sh
set -e
INPUT=$(cat)
REASON=$(echo "$INPUT" | jq -r '.reason')

# 정상 종료 또는 사용자 종료 시에만 실행
if [ "$REASON" = "complete" ] || [ "$REASON" = "user_exit" ]; then
  echo "[Spec Graph] 세션 종료 — 스펙 검증 실행 중..." >&2

  # 전체 스펙 유효성 검증
  dotnet run --project tools/flow-cli -- spec-validate 2>&1 | while read line; do
    echo "[Spec Graph] $line" >&2
  done

  # 그래프 캐시 갱신
  dotnet run --project tools/flow-cli -- spec-graph --output .spec-cache/graph.json 2>/dev/null

  echo "[Spec Graph] ✅ 세션 종료 검증 완료" >&2
fi
```

```powershell
# .github/hooks/scripts/spec-session-end.ps1
$input = [Console]::In.ReadToEnd() | ConvertFrom-Json

if ($input.reason -in @("complete", "user_exit")) {
    Write-Error "[Spec Graph] 세션 종료 — 스펙 검증 실행 중..."

    & dotnet run --project tools/flow-cli -- spec-validate 2>&1 | ForEach-Object {
        Write-Error "[Spec Graph] $_"
    }

    & dotnet run --project tools/flow-cli -- spec-graph --output .spec-cache/graph.json 2>$null

    Write-Error "[Spec Graph] ✅ 세션 종료 검증 완료"
}

exit 0
```

**sessionStart — 세션 시작 시 스펙 상태 스냅샷**

```bash
#!/bin/bash
# .github/hooks/scripts/spec-session-start.sh
INPUT=$(cat)
SOURCE=$(echo "$INPUT" | jq -r '.source')

echo "[Spec Graph] 세션 시작 ($SOURCE) — 스펙 상태 로드 중..." >&2

# 그래프 캐시가 없으면 생성
if [ ! -f .spec-cache/graph.json ]; then
  dotnet run --project tools/flow-cli -- spec-graph --output .spec-cache/graph.json 2>/dev/null
fi

# 현재 스펙 요약 출력 (에이전트 컨텍스트에 참고용)
SPEC_COUNT=$(find docs/specs -name '*.json' 2>/dev/null | wc -l)
echo "[Spec Graph] 로드된 스펙: ${SPEC_COUNT}개" >&2
```

#### Layer 4 vs Layer 5 비교

| 구분 | Layer 4: Instructions | Layer 5: Agent Hooks |
|---|---|---|
| **메커니즘** | AI에게 텍스트로 지시 | 셸 스크립트 **프로그래밍 방식** 강제 실행 |
| **실행 보장** | AI가 잊거나 무시할 수 있음 | **반드시 실행됨** (hook이 등록되면 bypass 불가) |
| **실행 타이밍** | AI 판단에 의존 | 정확한 타이밍에 자동 실행 (`postToolUse`, `sessionEnd` 등) |
| **차단 능력** | 불가 (권고만) | `preToolUse`에서 `deny` 반환으로 **도구 실행 차단 가능** |
| **설정 위치** | `.github/copilot-instructions.md`, agents, skills | `.github/hooks/*.json` + 스크립트 |
| **적용 범위** | Copilot Chat, Copilot Workspace | **Copilot Coding Agent** (GitHub) + **Copilot CLI** (로컬) |
| **성능 영향** | 없음 (텍스트 지시) | hook 실행 시간만큼 지연 (5초 이내 권장, 최대 30초 기본) |
| **상호 보완** | ✅ 같이 사용 시 효과 극대화 | ✅ Instructions로 AI 의도 유도 + Hooks로 강제 검증 |

> **권장 전략**: Layer 4(Instructions)로 AI가 스펙을 "인식"하게 하고, Layer 5(Hooks)로 "검증을 강제"한다.
> Instructions만으로는 AI가 스펙 동기화를 깜빡할 수 있고, Hooks만으로는 AI가 스펙의 맥락을 이해하지 못한다.
> 두 계층을 함께 사용해야 **인식 + 강제 = 확실한 동기화**가 달성된다.

#### 성능 및 보안 고려사항

| 항목 | 권장 사항 |
|---|---|
| 실행 시간 | hook 스크립트는 **5초 이내** 완료 권장. `spec-validate`가 느리면 `--quick` 옵션 추가 고려 |
| `timeoutSec` | 기본 30초, `postToolUse`는 10초, `sessionEnd`는 30초로 설정 |
| 비동기 처리 | 무거운 작업(그래프 캐시 전체 재생성)은 백그라운드 처리 |
| 민감 데이터 | hook 스크립트에서 토큰, 비밀번호 로깅 금지 |
| 입력 검증 | `jq` 파싱 실패 시 graceful exit (exit 0) |
| 파일 권한 | hook 스크립트에 실행 권한 필요 (`chmod +x`) |

#### 파일 구조

```text
.github/
  hooks/
    spec-sync.json              ← hook 설정 파일
    scripts/
      spec-session-start.sh     ← sessionStart hook (Bash)
      spec-session-start.ps1    ← sessionStart hook (PowerShell)
      spec-post-tool.sh         ← postToolUse hook (Bash)
      spec-post-tool.ps1        ← postToolUse hook (PowerShell)
      spec-pre-tool.sh          ← preToolUse hook (Bash)
      spec-pre-tool.ps1         ← preToolUse hook (PowerShell)
      spec-session-end.sh       ← sessionEnd hook (Bash)
      spec-session-end.ps1      ← sessionEnd hook (PowerShell)
```

---

### 트리거별 실행 내용 요약

| 트리거 시점 | 계층 | 실행 내용 | 차단 여부 |
|---|---|---|---|
| **파일 저장** | VSCode Extension | 관련 스펙 알림 + 그래프 자동 새로고침 | 비차단 (알림만) |
| **커밋 전** | Git pre-commit | 변경 파일 → 스펙 참조 매핑 알림 + 스펙 파일 유효성 검사 | 스펙 유효성 실패 시 차단 |
| **커밋 후** | Git post-commit | 그래프 캐시 백그라운드 갱신 | 비차단 |
| **Push 전** | Git pre-push | `spec-validate --strict` + `spec-check-refs` 전체 검증 | 실패 시 push 차단 |
| **Push 후** | GitHub Actions | 스펙 검증 + stale 감지 + 그래프 캐시 갱신 | CI 결과로 표시 |
| **PR 생성/갱신** | GitHub Actions | 변경 스펙 리포트 + 자동 라벨링 + 영향 분석 | PR comment로 표시 |
| **AI 프롬프트** | Agent Instructions | 코드 변경 시 스펙 updatedAt 갱신 + validate 실행 | AI 워크플로우에 포함 |
| **에이전트 도구 실행 전** | Copilot Agent Hooks | 스펙 파일 삭제 차단, 위험 명령 거부 | `preToolUse` deny로 **차단 가능** |
| **에이전트 도구 실행 후** | Copilot Agent Hooks | 코드 편집 시 영향 스펙 자동 감지 + 스펙 수정 시 유효성 검사 | 비차단 (로깅) |
| **에이전트 세션 종료** | Copilot Agent Hooks | `spec-validate` 전체 검증 + 그래프 캐시 갱신 | 비차단 (리포트) |
| **정기 스케줄** | GitHub Actions cron | stale 스펙 탐지 (30일 미갱신) | 리포트 생성 |

### 도입 우선순위

| 순서 | 트리거 | 난이도 | 효과 | 비고 |
|---|---|---|---|---|
| 1 | **Copilot Instructions** (`.github/copilot-instructions.md`) | ⭐ 낮음 | 높음 | 파일 하나만 추가하면 즉시 적용. AI 기반 개발 시 가장 효과적 |
| 2 | **Copilot Agent Hooks** (`.github/hooks/*.json`) | ⭐ 낮음 | **최고** | JSON + 스크립트 추가만으로 적용. **프로그래밍 방식 강제** — AI가 잊을 수 없음 |
| 3 | **Agent 워크플로우** (`.github/agents/*.md`) | ⭐ 낮음 | 높음 | 기존 flow.agent.md에 단계 추가만으로 적용 |
| 4 | **Git pre-commit** | ⭐⭐ 중간 | 높음 | 모든 커밋에서 자동 실행, 팀 전체 강제 |
| 5 | **GitHub Actions on PR** | ⭐⭐ 중간 | 중간 | PR 리포트로 가시성 확보, 라벨링 자동화 |
| 6 | **VSCode Extension hooks** | ⭐⭐⭐ 높음 | 높음 | Extension 구현 필요, 실시간 피드백 최고 |
| 7 | **Git pre-push** | ⭐ 낮음 | 중간 | push 속도 저하 우려, `--no-verify` 우회 가능 |
| 8 | **Scheduled stale check** | ⭐ 낮음 | 낮음 | 보험성 장치, 주간 리포트 |

### CLI 확장 필요 사항 (🟡 계획)

위 트리거들이 효과적으로 동작하려면 다음 CLI 기능이 필요하다:

| 명령 | 상태 | 설명 |
|---|---|---|
| `flow spec-check-refs --changed-files <paths>` | 🟡 계획 | 특정 파일 목록에 매칭되는 스펙 ID 반환 |
| `flow spec-check-refs --warn-stale` | 🟡 계획 | 코드 변경 있으나 스펙 미갱신 시 warning |
| `flow spec-list --stale-days <N>` | 🟡 계획 | updatedAt이 N일 이상 경과된 스펙 목록 |
| `flow spec-auto-sync --from-diff` | 💡 아이디어 | Git diff 기반 스펙 updatedAt 일괄 갱신 |

---

# 🎯 시스템 기능 목록 정리

---

## 📦 A. Spec 관리

* [ ] JSON 스키마 정의 (schemaVersion + metadata 포함)
* [ ] 스키마 버전 마이그레이션 스크립트
* [ ] CRUD API (CLI)
* [ ] 유효성 검사 (필수 필드, 타입, 참조 무결성)
* [ ] 순환 참조 감지 (Kahn 알고리즘)
* [ ] orphan node 탐지
* [ ] 스펙 ID 네이밍 컨벤션 강제
* [ ] 백업/복구 명령
* [ ] 스펙 완결성 검증 (수락조건 3개+, 독립성, 측정가능성)
* [ ] 기존 코드에서 스펙 추출 보조 도구 (`flow spec-suggest`)
* [ ] GitHub Ref 연결 (`githubRefs` — issue / pr / discussion 번호)
* [ ] 문서 링크 연결 (`docLinks` — 상대 경로 / 외부 URL)

* [ ] 계층 트리 생성 (스펙 단위 및 Feature-Condition 계층 지원)

## 📊 B. 그래프 분석

* [ ] 계층 트리 생성
* [ ] 의존성 DAG 생성
* [ ] 영향 범위 계산 (depth 제한 포함)
* [ ] 변경 전파 계산
* [ ] 영향 시각적 강조
* [ ] 그래프 캐싱 (.spec-cache/)

---

## 🌐 C. VSCode Extension UI

### 읽기 전용
* [ ] 트리 뷰 (TreeView API)
* [ ] 그래프 뷰 (Webview + Cytoscape.js)
* [ ] 상세 패널
* [ ] evidence 표시
* [ ] 코드 링크 이동 (에디터에서 바로 열기)
* [ ] GitHub Refs 표시 (이슈/PR 번호 → 브라우저 열기)
* [ ] DocLinks 표시 (상대 경로 → 에디터 열기, URL → 브라우저 열기)
* [ ] 상태 색상 표시
* [ ] 대규모 그래프 가상화/청크 로딩
* [ ] depth/tag/status 필터

### 그래프 편집 (Edit Session)
* [ ] 노드 추가 (ID 자동 채번, 최소 필드 입력 UI)
* [ ] 노드 편집 (더블클릭 → 인라인 편집 패널)
* [ ] 노드 삭제 (의존성 경고 + 확인 UI)
* [ ] 의존성 연결 (드래그 & 드롭, 순환 실시간 감지)
* [ ] 의존성 해제 (엣지 우클릭 → 연결 제거)
* [ ] 노드 이동 / parent 변경 (드래그 & 드롭)
* [ ] 편집 세션 관리 (draft 상태 → 저장 / 취소)
* [ ] 변경 요약 패널 (저장 전 diff 확인)
* [ ] 저장 전 유효성 검사 자동 실행
* [ ] crash recovery (draft 자동 저장)
* [ ] Undo / Redo (스택 기반, Ctrl+Z / Ctrl+Y)
* [ ] 히스토리 패널 (시간순 오퍼레이션 목록, 특정 시점 점프)
* [ ] 외부 변경 충돌 감지 (merge / overwrite 선택)

---

## 🔍 D. 코드 연동

* [ ] Git diff 감지 (rename detection 포함)
* [ ] 파일 변경 → 관련 spec 표시
* [ ] 파일 존재 검증
* [ ] 경로 정규화 (POSIX, 대소문자 무시)
* [ ] 코드Refs 자동 제안
* [ ] GitHub Refs URL 자동 구성 (number → https://github.com/.../issues/{n})
* [ ] DocLinks 경로 유효성 검증 (`doc` 타입 — 파일 존재 여부)
* [ ] 엣지 케이스 테스트 (한글/공백/symlink)

---

## 📸 E. 동작 증거 시스템

* [ ] Screenshot 연결
* [ ] 로그 저장
* [ ] 실행 시간 기록
* [ ] 자동 검증 날짜 갱신
* [ ] 플랫폼 도구 사전 검사 + graceful skip
* [ ] CI 매트릭스 증거 수집 job 분리

---

## 📦 H. 구현 순서 결정

* [ ] 위상 정렬 기반 기계적 순서 결정 (`flow spec-order`)
* [ ] priority / conditions 수 기반 동일 depth 정렬
* [ ] AI 최적화 순서 (`flow spec-order --ai`)
* [ ] 기계적 vs AI 순서 비교 UI
* [ ] AI 근거(reasoning) 표시
* [ ] 의존성 제약 위반 자동 거부
* [ ] 순서 결과 저장 (`docs/specs/.ordering/latest.json`)
* [ ] 부분 순서 계산 (`--from {id}`)

---

## 🔒 F. 보안 및 권한 (Phase 2)

* [ ] VSCode Webview 전용 — 외부 접근 차단 (Phase 1)
* [ ] OAuth2 / SSO 연동 (Phase 2)
* [ ] JWT 세션 관리 (TTL 8h / refresh 7d)
* [ ] 역할 기반 권한 (viewer / editor / admin)
* [ ] 수정 API audit log

---

## 🧪 G. 테스트 연결 및 CI

### 스키마 및 데이터
* [ ] `tests` 배열 스키마 정의 (condition + feature 레벨)
* [ ] `e2eScenarios` 배열 스키마 정의
* [ ] `testSummary` 자동 계산 로직
* [ ] `lastRun` / `lastFailure` / `history` 갱신 로직
* [ ] `healthScore` / `flakyScore` / `trend` 계산 알고리즘
* [ ] v2 → v3 마이그레이션 스크립트

### CLI 명령
* [ ] `flow spec-test-sync --from {result-file}` — 테스트 결과 자동 동기화
* [ ] `flow spec-test-report` — 전체 테스트 상태 리포트
* [ ] `flow spec-test-report --format markdown` — CI summary 용
* [ ] `flow spec-validate --strict --check-tests` — 테스트 연결 검증 포함

### 테스트 연동
* [ ] xUnit 테스트 결과 JSON 파싱 어댑터
* [ ] Jest 테스트 결과 JSON 파싱 어댑터
* [ ] pytest 테스트 결과 JSON 파싱 어댑터
* [ ] 테스트 코드 어노테이션 파서 (`[Trait("Spec", "...")]`, `@pytest.mark.spec`)
* [ ] CI 파이프라인 연동 (GitHub Actions / Azure DevOps)

### 모니터링
* [ ] Flaky 테스트 자동 감지 및 quarantine
* [ ] 테스트 건강도 대시보드 (Webview 내 표시)
* [ ] 미해결 실패 추적 및 알림
* [ ] 테스트 커버리지 트렌드 추적

### 기존 항목
* [ ] Kahn 알고리즘 단위 테스트 (6개 이상 케이스)
* [ ] Git diff 파싱 통합 테스트
* [ ] VSCode Extension E2E 테스트
* [ ] 렌더링 성능 벤치마크 (500/1000/5000 노드)
* [ ] CI workflow: spec-validate + spec-graph + spec-test-sync
* [ ] PR 스펙 변경 자동 라벨링

---

## 🔄 I. 스펙 자동 동기화 트리거 (Hooks & Instructions)

### Git Hooks
* [ ] `.githooks/` 폴더 구성 + `install.ps1`에 `core.hooksPath` 자동 설정
* [ ] `pre-commit`: 변경 파일 → 스펙 codeRef 매핑 알림 + 스펙 파일 유효성 검사
* [ ] `post-commit`: 그래프 캐시 백그라운드 갱신
* [ ] `pre-push`: `spec-validate --strict` + `spec-check-refs` 전체 검증
* [ ] Windows PowerShell 버전 hook 스크립트

### GitHub Actions
* [ ] Push 시 스펙 검증 + stale 감지 workflow (`spec-sync.yml`)
* [ ] PR 변경 스펙 자동 리포트 + 라벨링 workflow (`spec-pr-report.yml`)
* [ ] 주간 stale 스펙 감지 scheduled workflow (`spec-stale-check.yml`)

### VSCode Extension Hooks
* [ ] `onDidSaveTextDocument`: 코드 파일 저장 시 관련 스펙 알림
* [ ] `onDidSaveTextDocument`: 스펙 파일 저장 시 그래프 자동 갱신
* [ ] `FileSystemWatcher`: `docs/specs/*.json` 외부 변경 감지 → 그래프 새로고침
* [ ] `onDidChangeActiveTextEditor`: 현재 파일 관련 스펙 사이드바 하이라이트
* [ ] `.vscode/tasks.json` 스펙 검증 태스크 등록

### AI Agent Instructions
* [ ] `.github/copilot-instructions.md` 스펙 동기화 규칙 추가
* [ ] `.github/agents/flow.agent.md` 구현 후 스펙 동기화 단계 추가
* [ ] `.github/skills/flow-spec-graph/SKILL.md` 자동 동기화 체크리스트 추가
* [ ] `.vscode/settings.json` Copilot codeGeneration instructions 설정

### Copilot Agent Hooks (`.github/hooks/`)
* [ ] `.github/hooks/spec-sync.json` hook 설정 파일 생성
* [ ] `postToolUse` hook — 코드 파일 편집/생성 후 영향 스펙 자동 감지
* [ ] `preToolUse` hook — 스펙 파일 직접 삭제 차단 (deny)
* [ ] `sessionEnd` hook — 세션 종료 시 `spec-validate` + 그래프 캐시 갱신
* [ ] `sessionStart` hook — 세션 시작 시 스펙 상태 스냅샷 로드
* [ ] Bash + PowerShell 듀얼 스크립트 작성

### CLI 확장 (트리거 지원)
* [ ] `flow spec-check-refs --changed-files <paths>` — 특정 파일에 매칭되는 스펙 ID 반환
* [ ] `flow spec-check-refs --warn-stale` — 코드 변경 있으나 스펙 미갱신 시 warning
* [ ] `flow spec-list --stale-days <N>` — updatedAt이 N일 이상 경과된 스펙 목록
* [ ] `flow spec-auto-sync --from-diff` — Git diff 기반 스펙 updatedAt 일괄 갱신 (💡 아이디어)

---

# 📉 7️⃣ 구현 시 예상 단점 및 해소 방안

## D0. 패러다임 전환: AI 시대의 스펙(Spec) 중심 개발

과거의 개발이 코드(Code) 중심이었다면, AI 시대의 개발자는 AI 에이전트에게 지시할 **"정확한 스펙(Spec)과 아키텍처 의존성"** 을 설계하고 검증하는 역할로 이동하고 있다.
따라서 본 시스템의 철학은 **"스펙 문서가 진실의 원천(Source of Truth, SoT)이며, 코드는 스펙의 다양한 구현체 중 하나일 뿐이다"** 라는 전제에서 출발한다.

> **설계 제언:**
> - 스펙 파일이 기계가 읽기 쉬운 JSON으로 출발하지만, 궁극적으로 인간(아키텍트/기획자)이 읽고 쓰기 쉬운 형태(예: Markdown + Frontmatter, YAML)로의 전환을 염두에 둔다.
> - 사용자가 JSON 날것을 보지 않도록, VSCode Extension을 통한 완벽한 읽기/쓰기 시각화 UI 가 필수 불가결한 핵심 요소이다.
> - 시스템이 복잡해 보일 수 있으나(과도한 엔지니어링 우려), 기존의 상용/엔터프라이즈 BDD 도구를 사용할 수 없거나 도입 비용이 부담되는 조직에게는 AI를 활용해 자사 맞춤형(Cost-effective) 스펙 그래프를 구축하는 것 자체가 강력한 경쟁력이 된다.

## D1. 운영 오버헤드

스펙을 JSON으로 유지·관리하는 것 자체가 추가 작업이다.
코드 변경 때마다 관련 스펙을 업데이트하지 않으면 그래프가 빠르게 낙후(stale)된다.
**"스펙 유지 = 추가 비용"** — 팀 규모가 작을수록 부담이 크다.

> **해소 방안:**
> - **스펙 stale 감지 자동화**: CI에서 `git diff` 기반으로 코드 변경은 있는데 관련 스펙 `updatedAt` 갱신이 없으면 warning 발생
> - **PR 체크리스트 강제**: PR 템플릿에 "관련 스펙 업데이트 여부" 체크박스 포함
> - **LLM 기반 스펙 초안 자동 생성**: 코드 변경 diff를 입력으로 받아 스펙 업데이트 제안 (`flow spec-suggest --from-diff`)
> - **최소 스펙 정책**: 처음에는 `id` + `title` + `status`만 필수, 나머지는 점진적으로 채우기

## D2. 이중 진실 원천 (Dual Source of Truth)

코드와 스펙이 별도 파일로 존재하므로, 둘 사이 동기화가 깨지면
스펙 그래프가 오히려 **잘못된 확신(false confidence)** 을 준다.
codeRef 자동 검증으로 완화 가능하나 100% 방지는 불가능.

> **해소 방안:**
> - **codeRef 건강도 대시보드**: 전체 codeRef 중 유효 비율을 % 표시 → stale 정도를 한눈에 파악
> - **freshness 지표**: 각 스펙에 `lastVerifiedAt` 필드 추가, 일정 기간(예: 30일) 미검증 시 "stale" 배지 표시
> - **Git hook 연동**: `pre-commit`에서 변경된 파일이 어떤 스펙의 codeRef에 포함되는지 알림
> - **궁극적 해소**: 코드 내 어노테이션(`// @spec F-010`)을 파싱하여 스펙 ↔ 코드 양방향 연결 — 스펙이 코드에서 파생되면 이중 원천 문제 완화

## D3. 학습 곡선

새 팀원은 스펙 ID 체계, 그래프 구조, CLI 명령어를 학습해야 한다.
온보딩 문서 및 스펙 작성 템플릿이 없으면 도입 초기 저항이 크다.

> **해소 방안:**
> - **`flow spec-init` 인터랙티브 위저드**: 질문에 답하면 스펙 JSON 자동 생성 (ID 자동 채번 포함)
> - **스펙 템플릿**: `docs/specs/.templates/` 폴더에 기능별 템플릿 제공 (feature, bugfix, refactor)
> - **온보딩 가이드**: `docs/specs/GETTING_STARTED.md` — 5분 내 첫 스펙 생성 완료 목표
> - **VSCode snippets**: `spec-new` 입력 시 스펙 JSON 골격 자동 완성

## D4. 도구 종속성

VSCode Extension + Cytoscape.js + 커스텀 CLI에 의존하므로,
이 도구 체인을 유지보수할 인력이 필요하다.
도구가 방치되면 전체 스펙 시스템의 신뢰도가 떨어진다.

> **해소 방안:**
> - **계층 분리 아키텍처** (아래 8️⃣ 참조):
>   - **Core (spec-core)**: 스키마 검증, 그래프 분석 — 순수 라이브러리, UI 무관
>   - **CLI (flow spec)**: Core를 래핑한 CLI
>   - **UI (Extension 또는 Web)**: Core의 출력을 시각화
> - Core만 유지하면 CLI에서 모든 기능 사용 가능 → Extension이 방치되어도 핵심 기능 유지
> - 의존 라이브러리 최소화: Cytoscape.js 1개만 외부 의존, 나머지는 자체 구현
> - **Dependabot / Renovate** 설정으로 의존성 자동 업데이트 PR 생성

## D5. 스키마 진화 고통

초기 스키마 설계 실수가 있으면 마이그레이션 부담이 누적된다.
스키마 변경이 잦으면 `schemaVersion` 관리 자체가 복잡해진다.
→ **가능한 한 초기에 충분히 고민하고, 선택적 필드 위주로 확장.**

> **해소 방안:**
> - **Additive-only 원칙**: 기존 필드 삭제/변경 금지, 새 필드는 항상 optional + 기본값
> - **`metadata` 확장 필드**: 예측 못한 데이터는 `"metadata": {}` 자유 필드에 저장 → 스키마 변경 없이 실험 가능
> - **스키마 변경 RFC**: 필수 필드 변경 시 반드시 문서(`docs/specs/rfcs/`)에 배경·영향·마이그레이션 계획 기록 후 진행
> - **자동 마이그레이션 테스트**: 모든 버전 간 마이그레이션 경로를 CI에서 검증 (v1→v2, v1→v3 등)

## D6. 대규모 확장 시 성능 한계

수천 노드 + 복잡한 cross-dependency가 있으면
가상화/청크 로딩만으로는 한계가 올 수 있다.
이 경우 별도 백엔드(DB 기반 그래프 저장소)가 필요해질 수 있다.

> **해소 방안:**
> - **현실적 규모 판단**: 대부분의 프로젝트는 수백 노드 이내 — 파일 기반으로 충분
> - **전환 트리거 설정**: 노드 1000개 초과 or 그래프 빌드 5초 초과 시 DB 백엔드 도입 검토
> - **준비된 전환 경로**: Core 라이브러리의 데이터 소스를 인터페이스(`ISpecStore`)로 추상화
>   - Phase 1: `FileSpecStore` (JSON 파일)
>   - Phase 2: `SqliteSpecStore` (sqlite-vec, 이미 프로젝트에 활용 중)
> - **분할 그래프**: 도메인별 서브 그래프 분리 → 전체 로드 불필요

## D7. 증거 수집 파편화

플랫폼마다 증거 수집 방식이 달라 통합 뷰가 복잡하다.
Screenshot, 로그, 메트릭 형식이 제각각이면 evidence 표시 UI가 비대해진다.

> **해소 방안:**
> - **통합 Evidence 스키마**: 모든 증거를 동일 구조로 래핑
>   ```jsonc
>   { "type": "screenshot|log|metric|test-result",
>     "path": "...",
>     "capturedAt": "...",
>     "platform": "android|windows|unity",
>     "summary": "한 줄 요약" }
>   ```
> - **타입별 렌더러**: UI에서 `type`에 따라 이미지 뷰어 / 로그 하이라이터 / 차트 자동 선택
> - **증거 수집 어댑터 패턴**: 각 플랫폼별 어댑터가 공통 인터페이스 구현 → 새 플랫폼 추가 시 어댑터만 작성
> - **증거 갤러리 뷰**: 타임라인 기반 증거 나열 — 타입 무관하게 시간순 표시

---

# 🔀 8️⃣ 아키텍처 결정: VSCode Extension vs 웹 서비스

## 비교 분석

| 기준 | VSCode Extension | 독립 웹 서비스 | 하이브리드 (추천) |
|---|---|---|---|
| **초기 구축 비용** | 낮음 — Webview API로 빠르게 | 높음 — 서버, DB, 인증, 배포 | 중간 — Core 먼저, UI 나중에 |
| **인증/보안** | 불필요 (로컬) | 필수 (OAuth, JWT 등) | Phase 1 불필요, Phase 2에서 추가 |
| **에디터 통합** | ⭐ 최고 — 코드 링크 클릭 즉시 이동, Git 연동, 파일 감시 | ❌ 불가 — 별도 탭에서 열림 | ⭐ Phase 1에서 확보 |
| **비개발자 접근** | ❌ VSCode 설치 필요 | ⭐ 브라우저만 있으면 접근 | Phase 2에서 해소 |
| **실시간 협업** | ❌ 단일 사용자 | ⭐ 다중 사용자 동시 조회 | Phase 2에서 추가 가능 |
| **배포/인프라** | 없음 (로컬) | 서버 + DB + CI/CD 필요 | 점진적 추가 |
| **오프라인 사용** | ⭐ 완전 지원 | ❌ 서버 접근 필수 | Phase 1에서 확보 |
| **대규모 팀** | 한계 있음 | ⭐ 적합 | 확장 가능 |
| **유지보수 범위** | Extension + Webview | 프론트엔드 + 백엔드 + DB + 인프라 | Core 안정화 후 점진 확장 |

## 결론: 하이브리드 아키텍처 (추천)

**VSCode를 버릴 필요 없다.** 핵심은 **코어 엔진을 UI와 분리**하는 것이다.

```text
┌─────────────────────────────────────────────────┐
│                   spec-core                      │
│  (스키마 검증 · 그래프 분석 · 영향 계산 · CLI)      │
│  순수 라이브러리 — UI 무관, 단독 실행 가능           │
└────────────┬──────────────────┬──────────────────┘
             │                  │
     ┌───────▼───────┐  ┌──────▼──────────┐
     │ VSCode Ext.   │  │  Web Dashboard  │
     │ (Phase 1)     │  │  (Phase 2, 선택) │
     │               │  │                 │
     │ • TreeView    │  │ • 브라우저 접근   │
     │ • Webview     │  │ • 팀 대시보드    │
     │ • 코드 링크    │  │ • PM/QA 공유    │
     │ • 파일 감시     │  │ • 실시간 협업    │
     └───────────────┘  └─────────────────┘
```

### Phase 1 — VSCode Extension (지금)

| 이유 | 설명 |
|---|---|
| 개발자 워크플로우 최적 | 코드 ↔ 스펙 즉시 전환, 에디터 안에서 모든 작업 완결 |
| 인프라 비용 0 | 서버 없이 로컬에서 동작, 인증 불필요 |
| 빠른 MVP | Webview API + Cytoscape.js로 2~3주 내 시각화 가능 |
| 현재 프로젝트 규모 | 파일 기반 + CLI로 충분 |

### Phase 2 — 웹 대시보드 추가 (필요 시)

다음 조건 중 **2개 이상** 해당되면 웹 서비스 추가 검토:

- [ ] 팀원 5명 이상 동시 스펙 조회 필요
- [ ] PM/QA 등 비개발자 스펙 그래프 접근 필요
- [ ] VSCode 외 에디터(JetBrains, Vim 등) 사용자 존재
- [ ] 스펙 노드 500개 초과로 로컬 렌더링 한계
- [ ] 실시간 협업/댓글/리뷰 기능 필요

### Phase 2 구현 시 추가 사항

* **백엔드**: `spec-core`를 REST API로 래핑 (ASP.NET Minimal API 또는 Express)
* **프론트엔드**: 동일 Cytoscape.js 코드 재사용 (Webview → 브라우저 이식)
* **데이터 소스**: `FileSpecStore` → `SqliteSpecStore` 전환 (sqlite-vec 활용)
* **인증**: OAuth2 + JWT (R7 대응 방안 그대로 적용)
* **배포**: Docker Compose (app + sqlite) → 필요 시 클라우드

### 왜 "웹 서비스만"은 비추인가

| 문제 | 설명 |
|---|---|
| 에디터 통합 상실 | 스펙 그래프에서 코드 클릭 → 에디터 열기가 불가능. 개발자 UX 극적 하락 |
| 인프라 운영 부담 | 서버 유지, 모니터링, 백업, 보안 패치 — 소규모 팀에 과한 비용 |
| 오프라인 불가 | 네트워크 없는 환경에서 스펙 확인 불가 |
| 초기 속도 저하 | 인증/DB/배포 설정에 1~2주 추가 소요, MVP 늦어짐 |

---

# 💡 9️⃣ 개선 제안

문서 전체를 검토한 결과, 계획서 품질을 높이기 위한 제안 사항을 정리한다.

## P1. 상태 배지 도입 (현행 / 계획 / 아이디어)

각 기능 항목에 구현 단계를 명시하여 우선순위를 시각화한다.

| 배지 | 의미 | 적용 예시 |
|---|---|---|
| ✅ 현행 | 이미 구현됨 | `spec-init`, `spec-create`, `spec-validate`, `spec-graph`, `spec-impact`, `spec-propagate`, `spec-check-refs`, `spec-backup`, `spec-restore` |
| 🟡 계획 | 다음 단계에서 구현 예정 | `spec-migrate`, `spec-test-sync`, `spec-test-report`, `spec-order`, 그래프 편집 UI |
| 💡 아이디어 | 검토 단계, 구현 미정 | `spec-suggest`, 코드→스펙 자동 추론, 완전 자동 리팩토링 |

## P2. 로드맵 CLI 표

아직 구현되지 않은 CLI 명령을 별도 로드맵 표로 분리하여 CI 예시와 혼동을 방지한다.

| 명령 | 상태 | 설명 |
|---|---|---|
| `flow spec-migrate` | 🟡 계획 | 스키마 버전 마이그레이션 |
| `flow spec-log {id}` | 🟡 계획 | Git history 기반 스펙 변경 이력 |
| `flow spec-test-sync` | 🟡 계획 | 테스트 결과 → 스펙 동기화 |
| `flow spec-test-report` | 🟡 계획 | 테스트 상태 리포트 |
| `flow spec-order` | 🟡 계획 | 기계적 구현 순서 산출 |
| `flow spec-order --ai` | 🟡 계획 | AI 최적화 구현 순서 |
| `flow spec-suggest` | 💡 아이디어 | 코드 diff → 스펙 초안 생성 |

## P3. computedStatus 계산 규칙 명문화

`computedStatus`는 상위 스펙(parent)의 **표시 전용** 집계 상태다. 하위 스펙 `status` 기반으로 자동 계산:

| 조건 | computedStatus | 의미 |
|---|---|---|
| 모든 하위 `verified` | `stable` | 전체 검증 완료 |
| 하나라도 `needs-review` 또는 `active` | `partial` | 진행 중 |
| 하나라도 `deprecated` | `degraded` | 일부 폐기됨 |
| 모든 하위 `draft` | `blocked` | 시작 전 |
| 하위 스펙 없음 | `status` 값 그대로 | 말단 노드 |

우선순위: `blocked` > `degraded` > `partial` > `stable` (더 나쁜 상태가 이김)

## P4. CI 예시 분리 (현재 vs 목표)

CI/CD 통합 예시에서 현재 실행 가능한 명령과 계획 명령을 명확히 구분:

```yaml
# 현재 실행 가능
jobs:
  spec-lint:
    steps:
      - run: flow spec-validate --strict
      - run: flow spec-check-refs
      - run: flow spec-graph --output .spec-cache/graph.json

# 계획 (구현 후 추가)
  spec-test-sync:
    steps:
      - run: dotnet test --logger "json;LogFilePath=test-results.json"
      - run: flow spec-test-sync --from test-results.json    # 🟡 계획
      - run: flow spec-test-report --format markdown          # 🟡 계획
      - run: flow spec-order --output .spec-cache/order.json  # 🟡 계획
```

## P5. 문서 구조 개선

| 항목 | 제안 |
|---|---|
| 목차(TOC) 추가 | 문서 상단에 자동 생성 TOC 칸들을 넣어 탐색 용이성 확보 |
| 참조 파일 순순환 | `specs/constitution.md` 등 언급되는 파일이 실제로 존재하는지 확인·생성 |
| 용어 사전 추가 | "computedStatus", "edit session", "implementation queue" 등 신규 용어를 문서 초반에 정의 |
| 모든 JSON 예시에 유효성 검증 | 예시의 jsonc가 실제 카마/제어문자 누락 없이 파싱 가능한지 점검 |

---

## ⚠️ 치명적 취약점 및 개선 방향

### A. codeRefs의 라인 번호 의존성 (가장 큰 위험 요소)

**문제:**

스펙 스키마 예시에서 `"codeRefs": [".../AuthService.cs#L20-L30"]`처럼 **줄 번호(Line Numbers)** 를 사용하고 있다.
코드는 살아 움직인다. 누군가 상단에 `using` 문 하나만 추가해도 `L20-L30`은 어긋난다.
이는 무수한 **False Positive(잘못된 참조 오류)** 를 발생시키고 시스템의 신뢰도를 급격히 떨어뜨린다.

**해결책:**

라인 번호 대신 **AST(추상 구문 트리) 기반의 심볼(Symbol) 참조**를 사용한다.

| 현행 (취약) | 개선 (안정) |
|---|---|
| `AuthService.cs#L20-L30` | `AuthService.cs#Method:Login` |
| `TokenProvider.cs#L10-L45` | `TokenProvider.cs#Class:TokenProvider` |
| `AuthTests.cs#L15-L35` | `AuthTests.cs#Method:Login_WithValidCredentials_ReturnsToken` |

정밀도가 조금 떨어지더라도 **깨지지 않는 참조**가 훨씬 낫다.

**구현 방안:**

1. `codeRefs` 포맷을 `{파일경로}#{심볼타입}:{심볼이름}` 으로 확장
2. 심볼 타입: `Class`, `Method`, `Property`, `Interface`, `Function` 등
3. `flow spec-check-refs` 명령이 심볼 기반 검증을 수행하도록 확장
4. 기존 라인 번호 참조는 **하위 호환**으로 유지하되, 신규 작성 시 심볼 참조 권장
5. `flow spec-migrate-refs` 명령으로 라인 번호 → 심볼 참조 일괄 변환 (계획)

---

### B. 상태 데이터(State)의 JSON 하드코딩 (캐시 무효화의 악몽)

**문제:**

`lastRun`, `history`, `testSummary` 같은 **동적인 CI/CD 상태 데이터**를 정적인 JSON 파일에 기록하려는 설계는 위험하다.

- 테스트가 실행될 때마다 수많은 JSON 파일이 Git에 커밋되어야 한다.
- Git 히스토리를 **심각하게 오염**시킨다.
- 팀 환경에서 **Merge Conflict**를 유발한다.
- 스펙의 설계 변경 이력과 테스트 실행 이력이 뒤섞인다.

**해결책:**

JSON 파일은 **불변하는 스펙(설계, 의존성, 요구사항)** 만을 담는 **진실의 원천(Source of Truth)** 으로 유지한다.
테스트 결과나 실행 시간 등은 **별도의 캐시 레이어**에서 런타임에 그래프와 병합(Merge)하여 UI에 표시한다.

```text
┌───────────────────────────────────┐     ┌───────────────────────────────────┐
│   docs/specs/*.json (Git 관리)     │     │   .spec-cache/test-state.db       │
│                                   │     │   (SQLite, .gitignore 대상)        │
│  • id, title, description         │     │                                   │
│  • status, conditions             │     │  • lastRun, lastFailure           │
│  • dependencies, codeRefs         │     │  • history (totalRuns, passCount)  │
│  • requirements, edgeCases        │     │  • testSummary (healthScore 등)    │
│  • githubRefs, docLinks           │     │  • flakyScore, trend              │
│                                   │     │                                   │
│  ✅ 설계 데이터만 = 깨끗한 Git      │     │  ✅ 동적 데이터 = 런타임 관리       │
└───────────────────────────────────┘     └───────────────────────────────────┘
                │                                        │
                └────────────────┬───────────────────────┘
                                 │
                        ┌────────▼────────┐
                        │  UI / CLI 표시   │
                        │  (병합된 뷰)     │
                        └─────────────────┘
```

**마이그레이션 단계:**

| 단계 | 내용 |
|---|---|
| Phase 1 (현재) | JSON에 모든 데이터 포함 — 단일 사용자 환경에서는 문제 없음 |
| Phase 2 | `lastRun`, `history`, `testSummary`를 SQLite 캐시로 분리, JSON에는 `tests[].id`와 `tests[].testName`만 유지 |
| Phase 3 | CI 파이프라인이 SQLite 캐시를 직접 갱신, JSON 파일 변경 없이 테스트 상태 동기화 |

---

### C. "AI가 100% 가능"에 대한 과도한 낙관

**문제:**

문서 1장(기본 기능)에서 JSON 스펙 CRUD와 그래프 생성을 "AI 완전 가능"이라고 단언했다.
단일 노드 생성은 잘하겠지만, 수백 개의 노드가 얽힌 **DAG(방향성 비순환 그래프)** 구조에서:

- 컨텍스트를 잃지 않고 **정확한 의존성**을 맺어주기 어렵다.
- **순환 참조를 피하는 것**은 현재 LLM의 추론 능력으로 100% 보장하기 어렵다.
- 기존 스펙 전체를 컨텍스트 윈도우에 넣는 것이 물리적으로 제한된다.

**해결책:**

AI의 역할을 **'초안 제안자(Proposer)'** 로 명확히 한정하고, 최종 검증은 기계적 룰과 사람의 승인을 거쳐야 한다.

```text
[AI 생성 파이프라인]
  1. AI가 스펙 초안 생성 (JSON 구조, 의존성 후보 제안)
  2. 기계적 검증 (Kahn 알고리즘 순환 감지, 스키마 유효성, 참조 무결성)
  3. 검증 실패 시 → AI에게 오류 피드백 + 재생성 요청
  4. 검증 통과 시 → 사람에게 diff 표시 + 승인 요청
  5. 사람 승인 후 → 최종 저장
```

| AI 역할 (Proposer) | 기계적 검증 (Validator) | 사람 역할 (Approver) |
|---|---|---|
| JSON 초안 생성 | 스키마 유효성 검사 | 의존성 구조 검토 |
| 의존성 후보 제안 | 순환 참조 감지 (Kahn) | 비즈니스 로직 확인 |
| codeRefs 자동 매핑 | 참조 무결성 검증 | 최종 승인/거부 |
| 테스트 코드 생성 | 중복 ID 검사 | 우선순위 조정 |

---

### D. 스키마의 과도한 비대함 (인지 부하)

**문제:**

현재 v4 스키마는 너무 많은 정보를 담고 있다:
- `e2eScenarios`, `requirements`, `successCriteria`, `edgeCases`
- `tests[].lastRun`, `tests[].history`, `testSummary`
- `githubRefs`, `docLinks`

초기 도입 시 팀원들이 이 거대한 JSON 템플릿을 마주하면 **작성 자체를 포기할 확률이 높다**.

**해결책: Progressive Disclosure (점진적 공개)**

스펙 생성을 3단계로 나누어, 필요에 따라 점진적으로 정보를 채워 넣는다.

| 단계 | 필드 | 작성 주체 | 시점 |
|---|---|---|---|
| **Tier 1 (필수)** | `id`, `title`, `description`, `status`, `conditions` | 사람 | 스펙 최초 생성 시 |
| **Tier 2 (권장)** | `dependencies`, `parent`, `priority`, `codeRefs`, `tags` | 사람 + AI 보조 | 설계 확정 시 |
| **Tier 3 (자동)** | `tests`, `e2eScenarios`, `testSummary`, `requirements`, `successCriteria`, `edgeCases`, `evidence`, `githubRefs`, `docLinks` | AI 자동 채움(Backfill) | 구현·테스트 진행 중 |

**구현 방안:**

1. `flow spec-init`은 **Tier 1 필드만** 포함한 최소 JSON을 생성
2. `flow spec-enrich {id}` 명령으로 AI가 코드·테스트를 분석해 Tier 2~3 필드를 자동 제안
3. `flow spec-validate`는 Tier별 검증 수준 분리:
   - 기본: Tier 1만 검증
   - `--strict`: Tier 1 + 2 검증
   - `--full`: Tier 1 + 2 + 3 검증
4. VSCode Extension에서 Tier별 접이식(collapsible) UI 제공 — 초보자는 Tier 1만 보고, 필요 시 펼침

---
